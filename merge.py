#!/usr/bin/env python3
"""
merge_rust_to_merged.py

Merges all .rs files under /home/john/oxidity.builder/src into one merged.rs at
/home/john/oxidity.builder/merged.rs.

It hoists/deduplicates top-level Rust imports:
  - `use ...;`
  - `extern crate ...;`

and removes those lines from each file's body, then concatenates the bodies
with BEGIN/END separators.

Run:
  python3 merge_rust_to_merged.py
"""

from __future__ import annotations

import os
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Set, Tuple


SRC_DIR = Path("/home/john/oxidity.builder/src")
OUT_FILE = Path("/home/john/oxidity.builder/merged.rs")

# Skip these directories anywhere under SRC_DIR
SKIP_DIR_NAMES = {
    "__pycache__",
    ".pytest_cache",
    ".mypy_cache",
    ".ruff_cache",
    ".git",
    ".venv",
    "venv",
    "env",
    "dist",
    "build",
    "target",
    "node_modules",
}

# Optional: skip these files by name
SKIP_FILE_NAMES = {
    # "mod.rs",
    # "lib.rs",
    # "main.rs",
}

# Rust "import" patterns (line-based)
RE_USE = re.compile(r"^\s*(pub(\([^)]*\))?\s+)?use\s+.+;\s*$")
RE_EXTERN_CRATE = re.compile(r"^\s*(pub(\([^)]*\))?\s+)?extern\s+crate\s+.+;\s*$")

# Often worth not hoisting these because ordering/module semantics matter:
RE_MOD_DECL = re.compile(r"^\s*(pub(\([^)]*\))?\s+)?mod\s+\w+\s*;\s*$")

RE_SHEBANG = re.compile(r"^#!\s*/")  # uncommon in .rs, but just in case
RE_ATTR_CRATE = re.compile(r"^\s*#!\[[^\]]+\]\s*$")  # crate-level inner attributes (#![...])


@dataclass(frozen=True)
class FileExtract:
    relpath: str
    fullpath: str
    extern_crates: List[str]
    uses: List[str]
    body: str


def iter_rs_files(root: Path) -> List[Path]:
    files: List[Path] = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in SKIP_DIR_NAMES]

        for fn in filenames:
            if not fn.endswith(".rs"):
                continue
            if fn in SKIP_FILE_NAMES:
                continue
            p = Path(dirpath) / fn
            files.append(p)

    files.sort(key=lambda p: str(p).lower())
    return files


def dedupe_preserve_order(items: Iterable[str]) -> List[str]:
    seen: Set[str] = set()
    out: List[str] = []
    for it in items:
        key = " ".join(it.strip().split())
        if key in seen:
            continue
        seen.add(key)
        out.append(it.rstrip())
    return out


def extract_from_file(path: Path, root: Path) -> FileExtract:
    text = path.read_text(encoding="utf-8", errors="replace")
    lines = text.splitlines(keepends=False)

    extern_crates: List[str] = []
    uses: List[str] = []
    body_lines: List[str] = []

    # We will *not* hoist crate-level inner attributes (#![...]) because they
    # must appear at the crate root and ordering matters. We'll keep them in-place,
    # but we also collect them if they appear so you can see them in output.
    # (They'll remain in file bodies.)
    for line in lines:
        # Strip weird shebangs
        if RE_SHEBANG.match(line):
            continue

        # Keep mod decls in-place (they often change meaning when merged)
        if RE_MOD_DECL.match(line):
            body_lines.append(line)
            continue

        if RE_EXTERN_CRATE.match(line):
            extern_crates.append(line.strip())
            continue

        if RE_USE.match(line):
            uses.append(line.strip())
            continue

        body_lines.append(line)

    body = "\n".join(body_lines).rstrip() + "\n"
    return FileExtract(
        relpath=str(path.relative_to(root)),
        fullpath=str(path),
        extern_crates=extern_crates,
        uses=uses,
        body=body,
    )


def main() -> int:
    if not SRC_DIR.exists():
        print(f"[!] SRC_DIR does not exist: {SRC_DIR}")
        return 1

    rs_files = iter_rs_files(SRC_DIR)
    if not rs_files:
        print(f"[!] No .rs files found under {SRC_DIR}")
        return 1

    extracts: List[FileExtract] = []
    all_externs: List[str] = []
    all_uses: List[str] = []

    for f in rs_files:
        ex = extract_from_file(f, SRC_DIR)
        extracts.append(ex)
        all_externs.extend(ex.extern_crates)
        all_uses.extend(ex.uses)

    extern_unique = dedupe_preserve_order(all_externs)
    uses_unique = dedupe_preserve_order(all_uses)

    out: List[str] = []
    out.append("// Auto-generated merged Rust file\n")
    out.append(f"// Source: {SRC_DIR}\n")
    out.append(f"// Generated by: {Path(__file__).name}\n\n")

    # extern crate typically goes before use (old-school, but safe)
    if extern_unique:
        out.append("// --- extern crate (deduplicated) ---\n")
        for s in extern_unique:
            out.append(s + "\n")
        out.append("\n")

    if uses_unique:
        out.append("// --- use imports (deduplicated) ---\n")
        for s in uses_unique:
            out.append(s + "\n")
        out.append("\n")

    out.append("// --- merged sources ---\n")

    for ex in extracts:
        out.append("\n")
        out.append("//" + "=" * 98 + "\n")
        out.append(f"// BEGIN: {ex.relpath}\n")
        out.append("//" + "=" * 98 + "\n")
        out.append(ex.body)
        out.append("//" + "=" * 98 + "\n")
        out.append(f"// END:   {ex.relpath}\n")
        out.append("//" + "=" * 98 + "\n")

    OUT_FILE.write_text("".join(out), encoding="utf-8")
    print(f"[+] Wrote merged file: {OUT_FILE}")
    print(f"[+] Files merged: {len(extracts)}")
    print(f"[+] Unique use imports: {len(uses_unique)} | extern crate: {len(extern_unique)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
