// Auto-generated merged Rust file
// Source: /home/john/oxidity.builder/src
// Generated by: merge.py

// --- use imports (deduplicated) ---
use crate::domain::constants;
use crate::domain::error::AppError;
use alloy::primitives::Address;
use config::{Config, Environment, File};
use serde::{Deserialize, Deserializer};
use std::fs;
use std::collections::HashMap;
use std::str::FromStr;
use std::path::Path;
use serde::de::{Error, SeqAccess, Visitor};
use std::fmt;
use chrono::Utc;
use serde::Serialize;
use std::sync::{Arc, Mutex, OnceLock};
use tracing_subscriber::{fmt, prelude::*, reload, EnvFilter, Registry};
pub use crate::app::logging as logger;
pub use crate::domain::constants;
pub use crate::domain::error;
pub use crate::services::metrics;
use std::future::Future;
use std::time::Duration;
use tokio::time::sleep;
use super::*;
use std::sync::atomic::{AtomicUsize, Ordering};
use alloy::primitives::{Address, U256, address};
use lazy_static::lazy_static;
use thiserror::Error;
use crate::common::error::AppError;
use alloy_json_abi::JsonAbi;
use crate::data::schema::TransactionRecord;
use sqlx::{Pool, Row, Sqlite, sqlite::SqlitePoolOptions};
use alloy::sol;
use chrono::NaiveDateTime;
use sqlx::FromRow;
use serde::Deserialize;
use crate::common::retry::retry_async;
use crate::network::provider::HttpProvider;
use alloy::providers::Provider;
use alloy::rpc::types::BlockNumberOrTag;
use alloy::rpc::types::eth::FeeHistory;
use alloy::primitives::{Address, B256, U256};
use dashmap::DashSet;
use futures::StreamExt;
use reqwest::Client;
use std::sync::Arc;
use tokio::sync::mpsc::UnboundedSender;
use tokio::time::{Duration, sleep};
use crate::core::strategy::StrategyWork;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use alloy::network::Ethereum;
use alloy::providers::RootProvider;
use alloy_rpc_client::BuiltInConnectionString;
use std::path::PathBuf;
use url::Url;
pub use infrastructure::data;
pub use infrastructure::network;
pub use services::strategy as core;
use alloy::signers::local::PrivateKeySigner;
use clap::Parser;
use oxidity_builder::app::config::GlobalSettings;
use oxidity_builder::app::logging::setup_logging;
use oxidity_builder::domain::error::AppError;
use oxidity_builder::infrastructure::data::db::Database;
use oxidity_builder::infrastructure::data::token_manager::TokenManager;
use oxidity_builder::infrastructure::network::gas::GasOracle;
use oxidity_builder::infrastructure::network::price_feed::PriceFeed;
use oxidity_builder::infrastructure::network::provider::ConnectionFactory;
use oxidity_builder::services::strategy::engine::Engine;
use oxidity_builder::services::strategy::nonce::NonceManager;
use oxidity_builder::services::strategy::portfolio::PortfolioManager;
use oxidity_builder::services::strategy::safety::SafetyGuard;
use oxidity_builder::services::strategy::simulation::Simulator;
use std::collections::HashSet;
use crate::app::logging::{recent_logs, set_log_level};
use crate::core::portfolio::PortfolioManager;
use crate::core::strategy::StrategyStats;
use serde_json::json;
use std::net::SocketAddr;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;
use crate::core::nonce::NonceManager;
use crate::network::provider::WsProvider;
use alloy::rpc::types::Header;
use tokio::sync::broadcast::Sender;
use crate::core::block_listener::BlockListener;
use crate::core::executor::{BundleSender, SharedBundleSender};
use crate::core::mempool::MempoolScanner;
use crate::core::safety::SafetyGuard;
use crate::core::simulation::Simulator;
use crate::core::strategy::{StrategyExecutor, StrategyStats};
use crate::data::db::Database;
use crate::infrastructure::data::token_manager::TokenManager;
use crate::network::gas::GasOracle;
use crate::network::mev_share::MevShareClient;
use crate::network::price_feed::PriceFeed;
use crate::network::provider::{HttpProvider, WsProvider};
use tokio::sync::{broadcast, mpsc};
use alloy::primitives::keccak256;
use alloy::signers::SignerSync;
use reqwest::header::HeaderValue;
use std::time::{SystemTime, UNIX_EPOCH};
use alloy::consensus::Transaction as _;
use alloy::rpc::types::Transaction;
use crate::common::constants::LOW_BALANCE_THRESHOLD_WEI;
use alloy::primitives::{Address, I256, U256};
use dashmap::DashMap;
use crate::data::executor::UnifiedHardenedExecutor;
use alloy::rpc::types::eth::Transaction;
use alloy::rpc::types::eth::TransactionRequest;
use alloy::rpc::types::eth::simulate::{SimBlock, SimulatePayload};
use alloy::rpc::types::eth::state::StateOverride;
use alloy::sol_types::SolInterface;
use alloy_sol_types::{Revert, SolError};
use crate::core::executor::{BundleItem, SharedBundleSender};
use crate::data::executor::{FlashCallbackData, UnifiedHardenedExecutor};
use crate::network::gas::{GasFees, GasOracle};
use crate::network::mev_share::MevShareHint;
use alloy::consensus::{SignableTransaction, Transaction as ConsensusTxTrait, TxEip1559};
use alloy::eips::eip2718::Encodable2718;
use alloy::eips::eip2930::{AccessList, AccessListItem};
use alloy::network::{TransactionResponse, TxSignerSync};
use alloy::primitives::{aliases::U24, Address, B256, Bytes, I256, TxKind, U256, address};
use alloy::rpc::types::eth::TransactionInput;
use alloy::rpc::types::eth::state::StateOverridesBuilder;
use alloy::sol_types::SolCall;
use alloy_consensus::TxEnvelope;
use alloy_sol_types::SolValue;
use std::ops::Neg;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use tokio::sync::{broadcast::Receiver, mpsc::UnboundedReceiver, Mutex};
use crate::common::constants::WETH_MAINNET;
use alloy::primitives::{U160, aliases::U24};

// --- merged sources ---

//==================================================================================================
// BEGIN: app/config.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Debug, Deserialize, Clone)]
pub struct GlobalSettings {
    // General
    #[serde(default = "default_debug")]
    pub debug: bool,
    #[serde(default = "default_chain", deserialize_with = "deserialize_chain_list")]
    pub chains: Vec<u64>,

    // Identity
    pub wallet_key: String,
    pub wallet_address: Address,
    pub profit_receiver_address: Option<Address>,

    // Transaction
    #[serde(default = "default_max_gas")]
    pub max_gas_price_gwei: u64,
    #[serde(default = "default_sim_backend")]
    pub simulation_backend: String, // "revm", "anvil", etc.

    // MEV
    #[serde(default = "default_true")]
    pub flashloan_enabled: bool,
    pub executor_address: Option<Address>,
    #[serde(default = "default_true")]
    pub sandwich_attacks_enabled: bool,
    pub rpc_urls: Option<HashMap<String, String>>,
    pub ws_urls: Option<HashMap<String, String>>,
    pub ipc_urls: Option<HashMap<String, String>>,
    pub chainlink_feeds: Option<HashMap<String, String>>, // Symbol -> aggregator address
    pub flashbots_relay_url: Option<String>,
    pub bundle_signer_key: Option<String>,
    #[serde(default = "default_bribe_bps")]
    pub executor_bribe_bps: u64,
    pub executor_bribe_recipient: Option<Address>,
    pub tokenlist_path: Option<String>,
    #[serde(default = "default_metrics_port")]
    pub metrics_port: u16,
    #[serde(default = "default_true")]
    pub strategy_enabled: bool,
    #[serde(default = "default_slippage_bps")]
    pub slippage_bps: u64,
    pub gas_caps_gwei: Option<HashMap<String, u64>>,
    #[serde(default = "default_mev_share_url")]
    pub mev_share_stream_url: String,
    #[serde(default = "default_mev_share_history_limit")]
    pub mev_share_history_limit: u32,
    #[serde(default = "default_true")]
    pub mev_share_enabled: bool,

    // Per-chain maps
    pub router_allowlist_by_chain: Option<HashMap<String, HashMap<String, String>>>,
    pub chainlink_feeds_by_chain: Option<HashMap<String, HashMap<String, String>>>,
}

// Defaults
fn default_debug() -> bool {
    false
}
fn default_chain() -> Vec<u64> {
    vec![1]
}
fn default_max_gas() -> u64 {
    200
}
fn default_true() -> bool {
    true
}
fn default_metrics_port() -> u16 {
    9000
}
fn default_slippage_bps() -> u64 {
    50
}
fn default_sim_backend() -> String {
    "revm".to_string()
}
fn default_mev_share_url() -> String {
    "https://mev-share.flashbots.net".to_string()
}
fn default_mev_share_history_limit() -> u32 {
    200
}
fn default_bribe_bps() -> u64 {
    0
}

fn deserialize_chain_list<'de, D>(deserializer: D) -> Result<Vec<u64>, D::Error>
where
    D: Deserializer<'de>,
{

    struct ChainVisitor;

    impl<'de> Visitor<'de> for ChainVisitor {
        type Value = Vec<u64>;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("a sequence of chain ids or a string with comma-separated ids")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: Error,
        {
            parse_chain_list(v).map_err(E::custom)
        }

        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: SeqAccess<'de>,
        {
            let mut out = Vec::new();
            while let Some(elem) = seq.next_element::<u64>()? {
                out.push(elem);
            }
            Ok(out)
        }
    }

    deserializer.deserialize_any(ChainVisitor)
}

impl GlobalSettings {
    pub fn load_with_path(path: Option<&str>) -> Result<Self, AppError> {
        // Load .env file if it exists
        dotenvy::dotenv().ok();

        let active_config = detect_active_config_file();
        let mut builder = Config::builder();

        match active_config {
            Some(ref active_path) => {
                // Environment is lower priority; active config wins
                builder = builder
                    .add_source(Environment::default())
                    .add_source(File::from(Path::new(active_path)).required(true));
            }
            None => {
                if let Some(path) = path {
                    builder = builder.add_source(File::with_name(path).required(true));
                } else {
                    builder = builder.add_source(File::with_name("config").required(false));
                }
                // Environment (and .env) override non-active configs
                builder = builder.add_source(Environment::default());
            }
        }

        let mut settings: GlobalSettings = builder.build()?.try_deserialize()?;

        // Allow CHAINS env to be comma/space separated string (e.g. "1,137")
        if active_config.is_none() {
            if let Ok(chains_str) = std::env::var("CHAINS") {
                settings.chains = parse_chain_list(&chains_str)?;
            }
        }

        // Basic Validation
        if settings.wallet_key.is_empty() {
            return Err(AppError::Config("WALLET_KEY is missing".to_string()));
        }

        Ok(settings)
    }

    pub fn load() -> Result<Self, AppError> {
        Self::load_with_path(None)
    }

    /// Helper to get RPC URL for a specific chain
    pub fn get_rpc_url(&self, chain_id: u64) -> Result<String, AppError> {
        // Try looking for explicit map
        if let Some(urls) = &self.rpc_urls {
            if let Some(url) = urls.get(&chain_id.to_string()) {
                return Ok(url.clone());
            }
        }

        // Fallback to env var convention: RPC_URL_1, RPC_URL_137
        let env_key = format!("RPC_URL_{}", chain_id);
        std::env::var(&env_key)
            .map_err(|_| AppError::Config(format!("No RPC URL found for chain {}", chain_id)))
    }

    /// Helper to get WS URL for a specific chain
    pub fn get_ws_url(&self, chain_id: u64) -> Result<String, AppError> {
        if let Some(urls) = &self.ws_urls {
            if let Some(url) = urls.get(&chain_id.to_string()) {
                return Ok(url.clone());
            }
        }

        let candidates = [
            format!("WS_URL_{}", chain_id),
            format!("WEBSOCKET_URL_{}", chain_id),
            format!("IPC_URL_{}", chain_id),
        ];

        for key in candidates {
            if let Ok(v) = std::env::var(&key) {
                return Ok(v);
            }
        }

        Err(AppError::Config(format!(
            "No WS URL found for chain {}",
            chain_id
        )))
    }

    /// Optional IPC URL for a specific chain, preferring explicit config, then env, then local Nethermind default.
    pub fn get_ipc_url(&self, chain_id: u64) -> Option<String> {
        if let Some(urls) = &self.ipc_urls {
            if let Some(url) = urls.get(&chain_id.to_string()) {
                return Some(url.clone());
            }
        }

        let candidates = [
            format!("IPC_URL_{}", chain_id),
            format!("IPC_PATH_{}", chain_id),
            "IPC_URL".to_string(),
            "IPC_PATH".to_string(),
        ];

        for key in candidates {
            if let Ok(v) = std::env::var(&key) {
                if !v.trim().is_empty() {
                    return Some(v);
                }
            }
        }

        // Local default for mainnet Nethermind.
        let default_ipc = "/mnt/pool/ethereum/nethermind/nethermind.ipc";
        if chain_id == 1 && Path::new(default_ipc).exists() {
            return Some(default_ipc.to_string());
        }

        None
    }

    pub fn get_chainlink_feed(&self, symbol: &str) -> Option<String> {
        self.chainlink_feeds
            .as_ref()
            .and_then(|m| m.get(&symbol.to_uppercase()).cloned())
    }

    pub fn profit_receiver_or_wallet(&self) -> Address {
        self.profit_receiver_address.unwrap_or(self.wallet_address)
    }

    pub fn tokenlist_path(&self) -> String {
        std::env::var("TOKENLIST_PATH")
            .ok()
            .or_else(|| self.tokenlist_path.clone())
            .unwrap_or_else(|| "data/tokenlist.json".to_string())
    }

    pub fn flashbots_relay_url(&self) -> String {
        self.flashbots_relay_url
            .clone()
            .or_else(|| std::env::var("FLASHBOTS_RELAY_URL").ok())
            .unwrap_or_else(|| "https://relay.flashbots.net".to_string())
    }

    pub fn bundle_signer_key(&self) -> String {
        self.bundle_signer_key
            .clone()
            .or_else(|| std::env::var("BUNDLE_SIGNER_KEY").ok())
            .unwrap_or_else(|| self.wallet_key.clone())
    }

    pub fn gas_cap_for_chain(&self, chain_id: u64) -> Option<u64> {
        self.gas_caps_gwei
            .as_ref()
            .and_then(|m| m.get(&chain_id.to_string()).cloned())
    }

    pub fn routers_for_chain(&self, chain_id: u64) -> Result<HashMap<String, Address>, AppError> {
        if let Some(map) = self
            .router_allowlist_by_chain
            .as_ref()
            .and_then(|m| m.get(&chain_id.to_string()))
        {
            return parse_address_map(map, "router_allowlist_by_chain");
        }

        Ok(constants::default_routers_for_chain(chain_id))
    }

    pub fn chainlink_feeds_for_chain(
        &self,
        chain_id: u64,
    ) -> Result<HashMap<String, Address>, AppError> {
        if let Some(map) = self
            .chainlink_feeds_by_chain
            .as_ref()
            .and_then(|m| m.get(&chain_id.to_string()))
        {
            return parse_address_map(map, "chainlink_feeds_by_chain");
        }

        if let Some(map) = &self.chainlink_feeds {
            return parse_address_map(map, "chainlink_feeds");
        }

        Ok(constants::default_chainlink_feeds(chain_id))
    }
}

fn detect_active_config_file() -> Option<String> {
    // Check common config.*.toml files first
    let priority_files = [
        "config.prod.toml",
        "config.dev.toml",
        "config.testnet.toml",
        "config.example.toml",
        "config.toml",
    ];

    for file in priority_files.iter() {
        if let Some(true) = config_has_active_flag(file) {
            return Some((*file).to_string());
        }
    }

    // Fallback: scan current dir for config.*.toml with THIS_ACTIVE = true
    if let Ok(entries) = fs::read_dir(".") {
        for entry in entries.flatten() {
            let path = entry.path();
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                if name.starts_with("config.") && name.ends_with(".toml") {
                    if let Some(true) = config_has_active_flag(name) {
                        return Some(name.to_string());
                    }
                }
            }
        }
    }

    None
}

fn config_has_active_flag(path: &str) -> Option<bool> {
    let p = Path::new(path);
    if !p.exists() {
        return None;
    }

    Config::builder()
        .add_source(File::from(p))
        .build()
        .ok()?
        .get_bool("THIS_ACTIVE")
        .ok()
}

fn parse_chain_list(raw: &str) -> Result<Vec<u64>, AppError> {
    let cleaned = raw.trim_matches(|c| c == '`' || c == '"' || c == '\'');
    let mut out = Vec::new();
    for part in cleaned.split(|c: char| c == ',' || c.is_whitespace()) {
        let p = part.trim();
        if p.is_empty() {
            continue;
        }
        let id: u64 = p
            .parse()
            .map_err(|_| AppError::Config(format!("Invalid chain id '{}'", p)))?;
        out.push(id);
    }
    if out.is_empty() {
        return Err(AppError::Config("CHAINS env is empty".into()));
    }
    Ok(out)
}

fn parse_address_map(
    raw: &HashMap<String, String>,
    field: &str,
) -> Result<HashMap<String, Address>, AppError> {
    raw.iter()
        .map(|(k, v)| {
            Address::from_str(v)
                .map(|addr| (k.to_uppercase(), addr))
                .map_err(|_| AppError::InvalidAddress(format!("{field}:{k} -> {v}")))
        })
        .collect()
}
//==================================================================================================
// END:   app/config.rs
//==================================================================================================

//==================================================================================================
// BEGIN: app/logging.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Debug, Clone, Serialize)]
pub struct LogRecord {
    pub timestamp: String,
    pub level: String,
    pub target: String,
    pub message: String,
}

const LOG_BUFFER_MAX: usize = 500;

static LOG_BUFFER: OnceLock<Arc<Mutex<Vec<LogRecord>>>> = OnceLock::new();
static LOG_RELOAD: OnceLock<reload::Handle<EnvFilter, Registry>> = OnceLock::new();

struct LogCaptureLayer {
    buffer: Arc<Mutex<Vec<LogRecord>>>,
}

impl<S> tracing_subscriber::Layer<S> for LogCaptureLayer
where
    S: tracing::Subscriber,
    for<'span> S: tracing_subscriber::registry::LookupSpan<'span>,
{
    fn on_event(
        &self,
        event: &tracing::Event<'_>,
        _ctx: tracing_subscriber::layer::Context<'_, S>,
    ) {
        let meta = event.metadata();
        let mut visitor = MessageVisitor::default();
        event.record(&mut visitor);

        let record = LogRecord {
            timestamp: Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true),
            level: meta.level().to_string(),
            target: meta.target().to_string(),
            message: visitor.message.unwrap_or_default(),
        };

        let mut buf = self.buffer.lock().unwrap();
        buf.push(record);
        if buf.len() > LOG_BUFFER_MAX {
            let drop = buf.len() - LOG_BUFFER_MAX;
            buf.drain(0..drop);
        }
    }
}

#[derive(Default)]
struct MessageVisitor {
    message: Option<String>,
}

impl tracing::field::Visit for MessageVisitor {
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn std::fmt::Debug) {
        if field.name() == "message" {
            self.message = Some(format!("{:?}", value));
        }
    }

    fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
        if field.name() == "message" {
            self.message = Some(value.to_string());
        }
    }
}

pub fn setup_logging(log_level: &str, json_format: bool) {
    let filter = EnvFilter::from_str(log_level).unwrap_or_else(|_| EnvFilter::new("info"));

    let (filter_layer, handle) = reload::Layer::new(filter);
    let _ = LOG_RELOAD.set(handle);

    let buffer = LOG_BUFFER
        .get_or_init(|| Arc::new(Mutex::new(Vec::with_capacity(LOG_BUFFER_MAX))));

    let capture_layer = LogCaptureLayer {
        buffer: buffer.clone(),
    };

    let subscriber = tracing_subscriber::registry()
        .with(filter_layer)
        .with(capture_layer);

    if json_format {
        let json_layer = fmt::layer()
            .json()
            .with_target(false)
            .with_current_span(false);
        subscriber.with(json_layer).init();
    } else {
        let fmt_layer = fmt::layer()
            .with_target(true)
            .with_thread_ids(true)
            .compact();
        subscriber.with(fmt_layer).init();
    }

    tracing::info!("Logging initialized. Level: {}", log_level);
}

pub fn set_log_level(level: &str) -> Result<(), String> {
    let handle = LOG_RELOAD
        .get()
        .ok_or_else(|| "Log level handle not initialized".to_string())?;
    let filter = EnvFilter::from_str(level).map_err(|e| e.to_string())?;
    handle.reload(filter).map_err(|e| e.to_string())
}

pub fn recent_logs(limit: usize) -> Vec<LogRecord> {
    let buf = LOG_BUFFER
        .get()
        .map(|b| b.lock().unwrap().clone())
        .unwrap_or_default();
    let len = buf.len();
    let take = limit.min(len);
    buf.into_iter().skip(len.saturating_sub(take)).collect()
}
//==================================================================================================
// END:   app/logging.rs
//==================================================================================================

//==================================================================================================
// BEGIN: app/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod config;
pub mod logging;
//==================================================================================================
// END:   app/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: common/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod retry;

// Re-export frequently used modules for backward compatibility
//==================================================================================================
// END:   common/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: common/retry.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


/// Retry an async operation with exponential backoff.
pub async fn retry_async<F, Fut, T, E>(
    mut op: F,
    attempts: usize,
    initial_delay: Duration,
) -> Result<T, E>
where
    F: FnMut(usize) -> Fut,
    Fut: Future<Output = Result<T, E>>,
{
    let mut delay = initial_delay;
    let mut attempt = 1;
    loop {
        match op(attempt).await {
            Ok(v) => return Ok(v),
            Err(e) if attempt < attempts => {
                sleep(delay).await;
                delay = delay.saturating_mul(2);
                attempt += 1;
                continue;
            }
            Err(e) => return Err(e),
        }
    }
}

#[cfg(test)]
mod tests {

    #[tokio::test]
    async fn retries_until_success() {
        let counter = AtomicUsize::new(0);
        let res: Result<u32, ()> = retry_async(
            |_| {
                let current = counter.fetch_add(1, Ordering::Relaxed);
                async move { if current < 2 { Err(()) } else { Ok(7) } }
            },
            4,
            Duration::from_millis(1),
        )
        .await;

        assert_eq!(res.unwrap(), 7);
        assert!(counter.load(Ordering::Relaxed) >= 3);
    }
}
//==================================================================================================
// END:   common/retry.rs
//==================================================================================================

//==================================================================================================
// BEGIN: domain/constants.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


// Common assets
pub const WETH_MAINNET: Address = address!("C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
pub const WETH_OPTIMISM: Address = address!("4200000000000000000000000000000000000006");
pub const WETH_ARBITRUM: Address = address!("82aF49447D8a07e3bd95BD0d56f35241523fBab1");
pub const WETH_POLYGON: Address = address!("7ceB23fD6bC0adD59E62ac25578270cFf1b9f619");
pub const WBNB_BSC: Address = address!("BB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c");

// =============================================================================
// NETWORK CONSTANTS
// =============================================================================

pub const CHAIN_ETHEREUM: u64 = 1;
pub const CHAIN_OPTIMISM: u64 = 10;
pub const CHAIN_BSC: u64 = 56;
pub const CHAIN_POLYGON: u64 = 137;
pub const CHAIN_ARBITRUM: u64 = 42161;

// Block times in seconds (approximate)
pub fn get_block_time(chain_id: u64) -> u64 {
    match chain_id {
        CHAIN_ETHEREUM => 12,
        CHAIN_BSC => 3,
        CHAIN_POLYGON | CHAIN_OPTIMISM | CHAIN_ARBITRUM => 2,
        _ => 12, // Default
    }
}

// =============================================================================
// GAS & TRANSACTION CONSTANTS
// =============================================================================

pub const DEFAULT_GAS_LIMIT: u64 = 250_000;
pub const MAX_GAS_LIMIT: u64 = 8_000_000;
pub const DEFAULT_PRIORITY_FEE_GWEI: u64 = 2;

// =============================================================================
// MEV CONSTANTS (Using U256 for precise Wei math)
// =============================================================================

lazy_static! {
    // 0.00002 ETH (accept small edges by default)
    pub static ref MIN_PROFIT_THRESHOLD_WEI: U256 = U256::from(20_000_000_000_000u64);

    // 0.05 ETH
    pub static ref LOW_BALANCE_THRESHOLD_WEI: U256 = U256::from(50_000_000_000_000_000u64);

    // Router Addresses (Mainnet)
    // -------------------------
    // DEX Routers / Executors
    // -------------------------

    pub static ref DEX_ROUTERS_MAINNET: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // Uniswap
        m.insert("uniswap_v2_router02", address!("7a250d5630B4cF539739dF2C5dAcb4c659F2488D"));
        m.insert("uniswap_v3_swaprouter", address!("E592427A0AEce92De3Edee1F18E0157C05861564"));
        m.insert("uniswap_v3_swaprouter02", address!("68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"));
        m.insert("uniswap_universal_router", address!("66a9893cC07D91D95644AEDD05D03f95e1dBA8Af"));
        m.insert("uniswap_permit2", address!("000000000022D473030F116dDEE9F6B43aC78BA3"));

        // Sushi
        m.insert("sushiswap_router", address!("d9e1cE17f2641f24aE83637ab66a2cca9C378B9F"));

        // Balancer
        m.insert("balancer_v2_vault", address!("BA12222222228d8Ba445958a75a0704d566BF2C8"));

        // Curve (pool address + router)
        m.insert("curve_3pool_susd_v2_swap", address!("a5407eae9ba41422680e2e00537571bcc53efbfd"));
        m.insert("curve_router", address!("99a58482BD75cbab83b27EC03CA68fF489b5788f"));

        // Aggregators / RFQ executors
        m.insert("oneinch_aggregation_router_v5", address!("1111111254EEB25477B68fb85Ed929f73A960582"));
        m.insert("zeroex_exchange_proxy", address!("def1c0ded9bec7f1a1670819833240f027b25eff"));

        m
    };

    pub static ref DEX_ROUTERS_OPTIMISM: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // Uniswap
        m.insert("uniswap_v3_swaprouter", address!("E592427A0AEce92De3Edee1F18E0157C05861564"));
        m.insert("uniswap_v3_swaprouter02", address!("68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"));
        m.insert("uniswap_universal_router", address!("851116D9223fabED8E56C0e6B8Ad0c31d98B3507"));
        m.insert("uniswap_permit2", address!("000000000022D473030F116dDEE9F6B43aC78BA3"));

        // Sushi (NOTE: NOT 1b02... on OP)
        m.insert("sushiswap_router", address!("2abf469074dc0b54d793850807e6eb5faf2625b1"));

        // Velodrome
        m.insert("velodrome_router_v2", address!("a062aE8A9c5e11aaA026fc2670B0D65cCc8B2858"));
        m.insert("velodrome_router_v1_legacy", address!("a132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9"));

        // Balancer
        m.insert("balancer_v2_vault", address!("BA12222222228d8Ba445958a75a0704d566BF2C8"));

        // Aggregators / RFQ executors
        m.insert("oneinch_aggregation_router_v5", address!("1111111254EEB25477B68fb85Ed929f73A960582"));
        m.insert("zeroex_exchange_proxy", address!("def1abe32c034e558cdd535791643c58a13acc10"));

        m
    };

    pub static ref DEX_ROUTERS_ARBITRUM: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // Uniswap
        m.insert("uniswap_v3_swaprouter", address!("E592427A0AEce92De3Edee1F18E0157C05861564"));
        m.insert("uniswap_v3_swaprouter02", address!("68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"));
        m.insert("uniswap_universal_router", address!("a51afafe0263b40edaef0df8781ea9aa03e381a3"));
        m.insert("uniswap_permit2", address!("000000000022D473030F116dDEE9F6B43aC78BA3"));

        // Sushi
        m.insert("sushiswap_router", address!("1b02dA8Cb0d097eB8D57A175b88c7D8b47997506"));

        // Camelot (v2 + v3)
        m.insert("camelot_router_v2", address!("c873fEcbd354f5A56E00E710B90EF4201db2448d"));
        m.insert("camelot_router_v3", address!("1F721E2E82F6676FCE4eA07A5958cF098D339e18"));

        // Balancer
        m.insert("balancer_v2_vault", address!("BA12222222228d8Ba445958a75a0704d566BF2C8"));

        // Aggregators / RFQ executors
        m.insert("oneinch_aggregation_router_v5", address!("1111111254EEB25477B68fb85Ed929f73A960582"));
        m.insert("zeroex_exchange_proxy", address!("def1c0ded9bec7f1a1670819833240f027b25eff"));

        m
    };

    pub static ref DEX_ROUTERS_POLYGON: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // Uniswap
        m.insert("uniswap_v3_swaprouter", address!("E592427A0AEce92De3Edee1F18E0157C05861564"));
        m.insert("uniswap_v3_swaprouter02", address!("68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"));
        m.insert("uniswap_universal_router", address!("1095692A6237d83C6a72F3F5eFEdb9A670C49223"));
        m.insert("uniswap_permit2", address!("000000000022D473030F116dDEE9F6B43aC78BA3"));

        // Sushi
        m.insert("sushiswap_router", address!("1b02dA8Cb0d097eB8D57A175b88c7D8b47997506"));

        // QuickSwap (UniV2-style)
        m.insert("quickswap_v2_router", address!("a5E0829CaCED8fFDD4De3c43696c57F7D7A678ff"));

        // Balancer
        m.insert("balancer_v2_vault", address!("BA12222222228d8Ba445958a75a0704d566BF2C8"));

        // Aggregators / RFQ executors
        m.insert("oneinch_aggregation_router_v5", address!("1111111254EEB25477B68fb85Ed929f73A960582"));
        m.insert("zeroex_exchange_proxy", address!("def1c0ded9bec7f1a1670819833240f027b25eff"));

        m
    };

    pub static ref DEX_ROUTERS_BSC: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // PancakeSwap (UniV2-style)
        m.insert("pancakeswap_v2_router", address!("10ED43C718714eb63d5aA57B78B54704E256024E"));

        // Aggregators / RFQ executors
        m.insert("oneinch_aggregation_router_v4", address!("11111112542d85B3EF69AE05771c2dCCff4fAa26"));

        m
    };

    pub static ref DEX_ROUTERS_BY_CHAIN: HashMap<u64, &'static HashMap<&'static str, Address>> = {
        let mut m = HashMap::new();
        m.insert(CHAIN_ETHEREUM, &*DEX_ROUTERS_MAINNET);
        m.insert(CHAIN_OPTIMISM, &*DEX_ROUTERS_OPTIMISM);
        m.insert(CHAIN_ARBITRUM, &*DEX_ROUTERS_ARBITRUM);
        m.insert(CHAIN_POLYGON, &*DEX_ROUTERS_POLYGON);
        m.insert(CHAIN_BSC, &*DEX_ROUTERS_BSC);
        m
    };

    // -------------------------
    // Chainlink Feeds (symbol -> aggregator)
    // -------------------------

    // Ethereum mainnet: kept your list, but made WBTC explicit (WBTC/BTC exists; WBTC/USD does not on mainnet)
    pub static ref CHAINLINK_FEEDS_MAINNET: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        m.insert("ETH_USD", address!("5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"));
        m.insert("BTC_USD", address!("F4030086522a5bEEa4988F8cA5B36dbC97BeE88c"));
        m.insert("LINK_USD", address!("2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c"));
        m.insert("USDC_USD", address!("8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6"));
        m.insert("USDT_USD", address!("3E7d1eAB13ad0104d2750B8863b489D65364e32D"));
        m.insert("DAI_USD", address!("Aed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9"));

        m.insert("AAVE_USD", address!("547a514d5e3769680Ce22B2361c10Ea13619e8a9"));
        m.insert("UNI_USD", address!("553303d460EE0afB37EdFf9bE42922D8FF63220e"));
        m.insert("MKR_USD", address!("ec1D1B3b0443256cc3860e24a46F108e699484Aa"));
        m.insert("COMP_USD", address!("dbd020CAeF83eFd542f4De03e3cF0C28A4428bd5"));
        m.insert("SNX_USD", address!("dc3ea94cd0ac27d9a86c180091e7f78c683d3699"));
        m.insert("CRV_USD", address!("Cd627aA160A6fA45Eb793D19Ef54f5062F20f33f"));

        // NOTE: this is stETH/ETH (not stETH/USD)
        m.insert("STETH_ETH", address!("CfE54B5cD566aB89272946F602D76Ea879CAb4a8"));

        // NOTE: WBTC/USD is not on Ethereum mainnet; this is WBTC/BTC.
        m.insert("WBTC_BTC", address!("fdFD9C85aD200c506Cf9e21F1FD8dd01932FBB23"));

        m
    };

    pub static ref CHAINLINK_FEEDS_OPTIMISM: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        m.insert("ETH_USD",  address!("13e3Ee699D1909E989722E753853AE30b17e08c5"));
        m.insert("BTC_USD",  address!("D702DD976Fb76Fffc2D3963D037dfDae5b04E593"));
        m.insert("WBTC_USD", address!("718A5788b89454aAE3A028AE9c111A29Be6c2a6F"));
        m.insert("LINK_USD", address!("Cc232dcFAAE6354cE191Bd574108c1aD03f86450"));

        m.insert("USDC_USD", address!("16a9FA2FDa030272Ce99B29CF780dFA30361E0f3"));
        m.insert("USDT_USD", address!("ECef79E109e997bCA29c1c0897ec9d7b03647F5E"));
        m.insert("DAI_USD",  address!("8dBa75e83DA73cc766A7e5a0ee71F656BAb470d6"));

        m.insert("OP_USD",   address!("0D276FC14719f9292D5C1eA2198673d1f4269246"));

        m
    };

    pub static ref CHAINLINK_FEEDS_ARBITRUM: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        m.insert("ETH_USD",  address!("639Fe6ab55C921f74e7fac1ee960C0B6293ba612"));
        m.insert("BTC_USD",  address!("6ce185860a4963106506C203335A2910413708e9"));
        m.insert("WBTC_USD", address!("d0C7101eACbB49F3deCcCc166d238410D6D46d57"));
        m.insert("LINK_USD", address!("86E53CF1B870786351Da77A57575e79CB55812CB"));

        m.insert("USDC_USD", address!("50834F3163758fcC1Df9973b6e91f0F0F0434aD3"));
        m.insert("USDT_USD", address!("3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7"));
        m.insert("DAI_USD",  address!("c5C8E77B397E531B8EC06BFb0048328B30E9eCfB"));

        m.insert("ARB_USD",  address!("b2A824043730FE05F3DA2efaFa1CBbe83fa548D6"));

        m
    };

    pub static ref CHAINLINK_FEEDS_POLYGON: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        // (Your previous 0x327e... was not the ETH/USD feed; correct feed below)
        m.insert("ETH_USD",  address!("F9680D99D6C9589e2a93a78A04A279e509205945"));
        m.insert("BTC_USD",  address!("c907E116054Ad103354f2D350FD2514433D57F6f"));
        m.insert("WBTC_USD", address!("DE31F8bFBD8c84b5360CFACCa3539B938dd78ae6"));
        m.insert("LINK_USD", address!("d9FFdb71EbE7496cC440152d43986Aae0AB76665"));

        m.insert("USDC_USD", address!("fE4A8cc5b5B2366C1B58Bea3858e81843581b2F7"));
        m.insert("USDT_USD", address!("0A6513e40db6EB1b165753AD52E80663aeA50545"));
        m.insert("DAI_USD",  address!("4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D"));

        m.insert("MATIC_USD", address!("AB594600376Ec9fD91F8e885dADF0CE036862dE0"));

        m
    };

    pub static ref CHAINLINK_FEEDS_BSC: HashMap<&'static str, Address> = {
        let mut m = HashMap::new();

        m.insert("BNB_USD", address!("0567F2323251f0AaB15c8dFb1967E4e8A7D42aEE"));
        m.insert("BTC_USD", address!("5741306c21795FdCBb9b265Ea0255F499DFe515C"));
        m.insert("ETH_USD", address!("143db3CEEfbdfe5631aDD3E50f7614B6ba708BA7"));
        m.insert("BUSD_USD", address!("cBb98864Ef56E9042e7d2efef76141f15731B82f"));

        m
    };

    pub static ref CHAINLINK_FEEDS_BY_CHAIN: HashMap<u64, &'static HashMap<&'static str, Address>> = {
        let mut m = HashMap::new();
        m.insert(CHAIN_ETHEREUM, &*CHAINLINK_FEEDS_MAINNET);
        m.insert(CHAIN_OPTIMISM, &*CHAINLINK_FEEDS_OPTIMISM);
        m.insert(CHAIN_ARBITRUM, &*CHAINLINK_FEEDS_ARBITRUM);
        m.insert(CHAIN_POLYGON, &*CHAINLINK_FEEDS_POLYGON);
        m.insert(CHAIN_BSC, &*CHAINLINK_FEEDS_BSC);
        m
    };

    pub static ref WRAPPED_NATIVE_BY_CHAIN: HashMap<u64, Address> = {
        let mut m = HashMap::new();
        m.insert(CHAIN_ETHEREUM, WETH_MAINNET);
        m.insert(CHAIN_OPTIMISM, WETH_OPTIMISM);
        m.insert(CHAIN_ARBITRUM, WETH_ARBITRUM);
        m.insert(CHAIN_POLYGON, WETH_POLYGON);
        m.insert(CHAIN_BSC, WBNB_BSC);
        m
    };
}

// =============================================================================
// LOGGING DEFAULTS
// =============================================================================

pub const DEFAULT_LOG_LEVEL: &str = "info";
pub const LOG_FILE_NAME: &str = "oxidity_builder.log";

pub fn default_routers_for_chain(chain_id: u64) -> HashMap<String, Address> {
    DEX_ROUTERS_BY_CHAIN
        .get(&chain_id)
        .map(|m| {
            m.iter()
                .map(|(k, v)| (k.to_string(), Address::from(*v)))
                .collect::<HashMap<String, Address>>()
        })
        .unwrap_or_default()
}

pub fn default_chainlink_feeds(chain_id: u64) -> HashMap<String, Address> {
    CHAINLINK_FEEDS_BY_CHAIN
        .get(&chain_id)
        .map(|m| {
            m.iter()
                .map(|(k, v)| (k.to_string(), Address::from(*v)))
                .collect::<HashMap<String, Address>>()
        })
        .unwrap_or_default()
}

pub fn wrapped_native_for_chain(chain_id: u64) -> Address {
    WRAPPED_NATIVE_BY_CHAIN
        .get(&chain_id)
        .copied()
        .unwrap_or(WETH_MAINNET)
}
//==================================================================================================
// END:   domain/constants.rs
//==================================================================================================

//==================================================================================================
// BEGIN: domain/error.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Error, Debug)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    Config(String),

    #[error("Initialization failed: {0}")]
    Initialization(String),

    #[error("Connection failed to endpoint: {0}")]
    Connection(String),

    #[error("Transaction failed: {hash:?}, reason: {reason}")]
    Transaction { hash: String, reason: String },

    #[error("Strategy execution error: {0}")]
    Strategy(String),

    #[error("Insufficient funds. Required: {required}, Available: {available}")]
    InsufficientFunds { required: String, available: String },

    #[error("External API error: {provider} responded with {status}")]
    ApiCall { provider: String, status: u16 },

    #[error("Validation failed for field {field}: {message}")]
    Validation { field: String, message: String },

    #[error("Address {0} is invalid or not checksummed")]
    InvalidAddress(String),

    #[error(transparent)]
    Unknown(#[from] anyhow::Error),
}

impl From<config::ConfigError> for AppError {
    fn from(err: config::ConfigError) -> Self {
        AppError::Config(err.to_string())
    }
}
//==================================================================================================
// END:   domain/error.rs
//==================================================================================================

//==================================================================================================
// BEGIN: domain/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod constants;
pub mod error;
//==================================================================================================
// END:   domain/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/abi.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub struct AbiRegistry {
    abis: HashMap<String, JsonAbi>,
}

impl AbiRegistry {
    pub fn new() -> Self {
        Self {
            abis: HashMap::new(),
        }
    }

    pub fn load_from_directory(&mut self, dir_path: &str) -> Result<(), AppError> {
        let path = Path::new(dir_path);

        if !path.exists() {
            return Err(AppError::Config(format!(
                "ABI directory not found: {}",
                dir_path
            )));
        }

        for entry in fs::read_dir(path).map_err(|e| AppError::Initialization(e.to_string()))? {
            let entry = entry.map_err(|e| AppError::Initialization(e.to_string()))?;
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                let file_stem = path
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown")
                    .to_string();

                let file_content = fs::read_to_string(&path).map_err(|e| {
                    AppError::Config(format!("Failed to read ABI {}: {}", file_stem, e))
                })?;

                let abi: JsonAbi = serde_json::from_str(&file_content).map_err(|e| {
                    AppError::Config(format!("Failed to parse ABI {}: {}", file_stem, e))
                })?;

                tracing::info!("Loaded ABI: {}", file_stem);
                self.abis.insert(file_stem, abi);
            }
        }
        Ok(())
    }

    pub fn get(&self, name: &str) -> Option<&JsonAbi> {
        self.abis.get(name)
    }
}
//==================================================================================================
// END:   infrastructure/data/abi.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/db.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Clone)]
pub struct Database {
    pool: Pool<Sqlite>,
}

impl Database {
    pub async fn new(database_url: &str) -> Result<Self, AppError> {
        let pool = SqlitePoolOptions::new()
            .max_connections(5)
            .connect(database_url)
            .await
            .map_err(|e| AppError::Initialization(format!("DB Connect failed: {}", e)))?;

        sqlx::migrate!("./migrations")
            .run(&pool)
            .await
            .map_err(|e| AppError::Initialization(format!("DB Migration failed: {}", e)))?;

        Ok(Self { pool })
    }

    pub async fn save_transaction(
        &self,
        tx_hash: &str,
        chain_id: u64,
        from: &str,
        to: Option<&str>,
        value: &str,
        strategy: Option<&str>,
    ) -> Result<i64, AppError> {
        let chain_id_i64 = chain_id as i64;

        let row = sqlx::query(
            r#"
            INSERT INTO transactions (tx_hash, chain_id, from_address, to_address, value_wei, strategy)
            VALUES (?, ?, ?, ?, ?, ?)
            RETURNING id
            "#,
        )
        .bind(tx_hash)
        .bind(chain_id_i64)
        .bind(from)
        .bind(to)
        .bind(value)
        .bind(strategy)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| AppError::Transaction {
            hash: tx_hash.to_string(),
            reason: e.to_string(),
        })?;
        let id: i64 = row.get("id");

        Ok(id)
    }

    pub async fn get_recent_txs(&self, limit: i64) -> Result<Vec<TransactionRecord>, AppError> {
        let recs = sqlx::query_as::<_, TransactionRecord>(
            "SELECT * FROM transactions ORDER BY timestamp DESC LIMIT ?",
        )
        .bind(limit)
        .fetch_all(&self.pool)
        .await
        .map_err(|e| AppError::Initialization(format!("Query failed: {}", e)))?;

        Ok(recs)
    }

    pub async fn save_profit_record(
        &self,
        tx_hash: &str,
        chain_id: u64,
        strategy: &str,
        profit_eth: f64,
        gas_cost_eth: f64,
        net_profit_eth: f64,
    ) -> Result<i64, AppError> {
        let chain_id_i64 = chain_id as i64;
        let row = sqlx::query(
            r#"
            INSERT INTO profit_records (tx_hash, chain_id, strategy, profit_eth, gas_cost_eth, net_profit_eth)
            VALUES (?, ?, ?, ?, ?, ?)
            RETURNING id
            "#,
        )
        .bind(tx_hash)
        .bind(chain_id_i64)
        .bind(strategy)
        .bind(profit_eth)
        .bind(gas_cost_eth)
        .bind(net_profit_eth)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| AppError::Initialization(format!("Profit insert failed: {}", e)))?;
        let id: i64 = row.get("id");

        Ok(id)
    }

    pub async fn update_status(
        &self,
        tx_hash: &str,
        block_number: Option<i64>,
        status: Option<bool>,
    ) -> Result<(), AppError> {
        sqlx::query(
            r#"
            UPDATE transactions
            SET block_number = COALESCE(?, block_number),
                status = COALESCE(?, status)
            WHERE tx_hash = ?
            "#,
        )
        .bind(block_number)
        .bind(status)
        .bind(tx_hash)
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Initialization(format!("Status update failed: {}", e)))?;

        Ok(())
    }

    pub async fn save_market_price(
        &self,
        chain_id: u64,
        symbol: &str,
        price_usd: f64,
        source: &str,
    ) -> Result<i64, AppError> {
        let chain_id_i64 = chain_id as i64;
        let row = sqlx::query(
            r#"
            INSERT INTO market_prices (chain_id, symbol, price_usd, source)
            VALUES (?, ?, ?, ?)
            RETURNING id
            "#,
        )
        .bind(chain_id_i64)
        .bind(symbol)
        .bind(price_usd)
        .bind(source)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| AppError::Initialization(format!("Market price insert failed: {}", e)))?;
        let id: i64 = row.get("id");

        Ok(id)
    }
}

#[cfg(test)]
mod tests {

    #[tokio::test]
    async fn profit_and_price_inserts() {
        let db = Database::new("sqlite::memory:").await.expect("db");
        let profit_id = db
            .save_profit_record("0xabc", 1, "test", 0.2, 0.05, 0.15)
            .await
            .unwrap();
        assert!(profit_id > 0);
        let price_id = db
            .save_market_price(1, "ETHUSD", 3200.0, "test")
            .await
            .unwrap();
        assert!(price_id > 0);
    }
}
//==================================================================================================
// END:   infrastructure/data/db.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/executor.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


sol! {
    #[sol(rpc)]
    interface UnifiedHardenedExecutor {
        function executeBundle(
            address[] calldata targets,
            bytes[] calldata payloads,
            uint256[] calldata values,
            address bribeRecipient,
            uint256 bribeAmount
        ) external payable;

        function executeFlashLoan(
            address[] calldata assets,
            uint256[] calldata amounts,
            bytes calldata params
        ) external;

        function safeApprove(address token, address spender, uint256 amount) external;
        function setProfitReceiver(address newReceiver) external;
        function setSweepPreference(bool sweepToEth) external;

        error OnlyOwner();
        error OnlyVault();
        error LengthMismatch();
        error ZeroAssets();
        error ExecutionFailed(uint256 index, bytes reason);
        error InsufficientFundsForRepayment(address token, uint256 required, uint256 available);
        error InvalidWETHAddress();
        error InvalidProfitReceiver();
        error TokenTransferFailed();
        error ApprovalFailed();
        error BribeFailed();
    }

    // Matches abi.decode(userData, (address[], uint256[], bytes[])) in receiveFlashLoan
    struct FlashCallbackData {
        address[] targets;
        uint256[] values;
        bytes[] payloads;
    }
}
//==================================================================================================
// END:   infrastructure/data/executor.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod abi;
pub mod db;
pub mod executor;
pub mod schema;
pub mod token_manager;
//==================================================================================================
// END:   infrastructure/data/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/schema.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Debug, FromRow)]
pub struct TransactionRecord {
    pub id: i64,
    pub tx_hash: String,
    pub chain_id: i64,
    pub block_number: Option<i64>,
    pub from_address: String,
    pub to_address: Option<String>,
    pub value_wei: String,
    pub gas_used: Option<i64>,
    pub gas_price_wei: Option<String>,
    pub status: Option<bool>,
    pub strategy: Option<String>,
    pub timestamp: NaiveDateTime,
    pub execution_time_ms: Option<f64>,
}

#[derive(Debug, FromRow)]
pub struct ProfitRecord {
    pub id: i64,
    pub tx_hash: String,
    pub chain_id: i64,
    pub strategy: String,
    pub profit_eth: f64,
    pub gas_cost_eth: f64,
    pub net_profit_eth: f64,
    pub timestamp: NaiveDateTime,
}
//==================================================================================================
// END:   infrastructure/data/schema.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/data/token_manager.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>




/// Minimal token metadata used for decimal-aware profit checks and logging.
#[derive(Debug, Clone)]
pub struct TokenInfo {
    pub symbol: String,
    pub decimals: u8,
    pub tags: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct TokenManager {
    tokens_by_chain: HashMap<u64, HashMap<Address, TokenInfo>>,
}

#[derive(Deserialize)]
struct TokenEntry {
    symbol: String,
    #[serde(default)]
    tags: Vec<String>,
    decimals: u8,
    #[serde(default)]
    addresses: HashMap<String, String>,
}

impl TokenManager {
    pub fn load_from_file(path: &str) -> Result<Self, AppError> {
        let raw = fs::read_to_string(path)
            .map_err(|e| AppError::Config(format!("Failed to read tokenlist {path}: {e}")))?;
        let entries: Vec<TokenEntry> = serde_json::from_str(&raw)
            .map_err(|e| AppError::Config(format!("Invalid tokenlist JSON {path}: {e}")))?;

        let mut tokens_by_chain: HashMap<u64, HashMap<Address, TokenInfo>> = HashMap::new();

        for entry in entries {
            for (chain_str, addr_str) in entry.addresses {
                if let Ok(chain_id) = chain_str.parse::<u64>() {
                    if let Ok(addr) = addr_str.parse::<Address>() {
                        tokens_by_chain.entry(chain_id).or_default().insert(
                            addr,
                            TokenInfo {
                                symbol: entry.symbol.clone(),
                                decimals: entry.decimals,
                                tags: entry.tags.clone(),
                            },
                        );
                    }
                }
            }
        }

        Ok(Self { tokens_by_chain })
    }

    pub fn decimals(&self, chain_id: u64, address: Address) -> Option<u8> {
        self.tokens_by_chain
            .get(&chain_id)
            .and_then(|m| m.get(&address))
            .map(|t| t.decimals)
    }

    pub fn info(&self, chain_id: u64, address: Address) -> Option<&TokenInfo> {
        self.tokens_by_chain
            .get(&chain_id)
            .and_then(|m| m.get(&address))
    }

    pub fn is_empty(&self) -> bool {
        self.tokens_by_chain.is_empty()
    }
}

impl Default for TokenManager {
    fn default() -> Self {
        Self {
            tokens_by_chain: HashMap::new(),
        }
    }
}
//==================================================================================================
// END:   infrastructure/data/token_manager.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod data;
pub mod network;
//==================================================================================================
// END:   infrastructure/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/network/gas.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Clone)]
pub struct GasOracle {
    provider: HttpProvider,
}

#[derive(Debug)]
pub struct GasFees {
    pub max_fee_per_gas: u128,
    pub max_priority_fee_per_gas: u128,
    pub base_fee_per_gas: u128,
}

impl GasOracle {
    pub fn new(provider: HttpProvider) -> Self {
        Self { provider }
    }

    pub async fn estimate_eip1559_fees(&self) -> Result<GasFees, AppError> {
        let history: FeeHistory = self.with_retry_history().await?;

        let last_base_fee = history
            .base_fee_per_gas
            .last()
            .ok_or(AppError::Initialization("No base fee history".into()))?;

        let next_base_fee = (last_base_fee * 1125) / 1000;

        let priority_fee = if let Some(rewards) = history.reward {
            let mut sum = 0u128;
            let mut count = 0;
            for block_reward in rewards {
                if let Some(r) = block_reward.first() {
                    sum += *r;
                    count += 1;
                }
            }
            if count > 0 {
                sum / count
            } else {
                2_000_000_000
            }
        } else {
            2_000_000_000
        };

        Ok(GasFees {
            max_fee_per_gas: next_base_fee + priority_fee,
            max_priority_fee_per_gas: priority_fee,
            base_fee_per_gas: *last_base_fee,
        })
    }
}

impl GasOracle {
    async fn with_retry_history(&self) -> Result<FeeHistory, AppError> {
        let provider = self.provider.clone();
        retry_async(
            move |_| {
                let provider = provider.clone();
                async move {
                    provider
                        .get_fee_history(5, BlockNumberOrTag::Latest, &[50.0f64])
                        .await
                }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Fee History failed: {}", e)))
    }
}
//==================================================================================================
// END:   infrastructure/network/gas.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/network/mev_share.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>



#[derive(Debug, Clone)]
pub struct MevShareHint {
    pub tx_hash: B256,
    pub router: Address,
    pub from: Option<Address>,
    pub call_data: Vec<u8>,
    pub value: U256,
    pub gas_limit: Option<u64>,
    pub max_fee_per_gas: Option<u128>,
    pub max_priority_fee_per_gas: Option<u128>,
}

#[derive(Debug, Deserialize)]
struct RawEvent {
    #[allow(dead_code)]
    hash: Option<String>,
    #[serde(default)]
    txs: Option<Vec<RawTx>>,
}

#[derive(Debug, Deserialize)]
struct RawTx {
    #[serde(rename = "hash")]
    hash: Option<String>,
    #[serde(rename = "to")]
    to: Option<String>,
    #[serde(rename = "from")]
    from: Option<String>,
    #[serde(rename = "callData")]
    call_data: Option<String>,
    #[serde(rename = "value")]
    value: Option<String>,
    #[serde(rename = "gas")]
    gas: Option<String>,
    #[serde(rename = "maxFeePerGas")]
    max_fee_per_gas: Option<String>,
    #[serde(rename = "maxPriorityFeePerGas")]
    max_priority_fee_per_gas: Option<String>,
    #[serde(rename = "chainId")]
    chain_id: Option<String>,
}

/// Very small SSE client for MEV-Share streams. Converts events into StrategyWork hints.
pub struct MevShareClient {
    base_url: String,
    history_url: String,
    client: Client,
    chain_id: u64,
    seen: Arc<DashSet<B256>>,
    tx_sender: UnboundedSender<StrategyWork>,
    history_limit: u32,
}

impl MevShareClient {
    pub fn new(
        base_url: String,
        chain_id: u64,
        tx_sender: UnboundedSender<StrategyWork>,
        history_limit: u32,
    ) -> Self {
        let history_url = format!("{}/api/v1/history", base_url.trim_end_matches('/'));
        Self {
            base_url,
            history_url,
            client: Client::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
            chain_id,
            seen: Arc::new(DashSet::new()),
            tx_sender,
            history_limit,
        }
    }

    pub async fn run(mut self) -> Result<(), AppError> {
        self.backfill_history().await?;
        loop {
            match self.stream_once().await {
                Ok(_) => {}
                Err(e) => {
                    tracing::warn!(target: "mev_share", error=%e, "Stream error, reconnecting");
                    sleep(Duration::from_secs(2)).await;
                }
            }
        }
    }

    async fn backfill_history(&mut self) -> Result<(), AppError> {
        if self.history_limit == 0 {
            return Ok(());
        }
        let url = format!("{}?limit={}", self.history_url, self.history_limit);
        let resp = self
            .client
            .get(&url)
            .send()
            .await
            .map_err(|e| AppError::Connection(format!("History request failed: {}", e)))?;
        if !resp.status().is_success() {
            tracing::warn!(
                target: "mev_share",
                status = %resp.status(),
                "History endpoint returned non-success"
            );
            return Ok(());
        }

        let raw: Vec<HistoricalRecord> = match resp.json().await {
            Ok(v) => v,
            Err(e) => {
                tracing::warn!(target: "mev_share", error=%e, "Failed to decode history response");
                return Ok(());
            }
        };

        for rec in raw {
            if let Some(evt) = rec.hint {
                self.handle_event(evt).await;
            }
        }
        Ok(())
    }

    async fn stream_once(&mut self) -> Result<(), AppError> {
        tracing::info!(target: "mev_share", url=%self.base_url, "Connecting to MEV-Share SSE");
        let resp = self
            .client
            .get(&self.base_url)
            .send()
            .await
            .map_err(|e| AppError::Connection(format!("SSE connect failed: {}", e)))?;
        if !resp.status().is_success() {
            return Err(AppError::Connection(format!(
                "SSE returned status {}",
                resp.status()
            )));
        }

        let mut stream = resp.bytes_stream();
        let mut buffer = String::new();

        while let Some(chunk) = stream.next().await {
            let chunk =
                chunk.map_err(|e| AppError::Connection(format!("SSE chunk error: {}", e)))?;
            buffer.push_str(&String::from_utf8_lossy(&chunk));

            while let Some(idx) = buffer.find("\n\n") {
                let event = buffer[..idx].to_string();
                buffer = buffer[idx + 2..].to_string();

                let mut data_lines = Vec::new();
                for line in event.lines() {
                    let line = line.trim_end_matches('\r');
                    if line.starts_with(':') {
                        continue;
                    }
                    if let Some(data) = line.strip_prefix("data:") {
                        data_lines.push(data.trim());
                    }
                }

                if data_lines.is_empty() {
                    continue;
                }

                let data = data_lines.join("\n");
                match serde_json::from_str::<Option<RawEvent>>(&data) {
                    Ok(Some(evt)) => self.handle_event(evt).await,
                    Ok(None) => {
                        // null or empty payloads are valid keep-alives from the service
                        tracing::debug!(target: "mev_share", "Ignored null SSE payload");
                    }
                    Err(e) => {
                        tracing::warn!(target: "mev_share", error=%e, "Failed to parse SSE data");
                    }
                }
            }
        }

        Err(AppError::Connection("SSE stream ended unexpectedly".into()))
    }

    async fn handle_event(&self, evt: RawEvent) {
        let Some(txs) = evt.txs else { return };

        for tx in txs {
            if let Some(hint) = self.convert_hint(tx) {
                let key = hint.tx_hash;
                if self.seen.insert(key) {
                    let _ = self.tx_sender.send(StrategyWork::MevShareHint(hint));
                }
            }
        }
    }

    fn convert_hint(&self, raw: RawTx) -> Option<MevShareHint> {
        let tx_hash = raw.hash.as_deref().and_then(parse_b256)?;
        let router = raw.to.as_deref().and_then(parse_address)?;
        let chain_ok = raw
            .chain_id
            .as_deref()
            .and_then(parse_u64_hex)
            .map(|cid| cid == self.chain_id)
            .unwrap_or(true);
        if !chain_ok {
            return None;
        }

        let call_data = raw
            .call_data
            .as_deref()
            .and_then(parse_hex_bytes)
            .filter(|v| !v.is_empty())?;

        let value = raw
            .value
            .as_deref()
            .and_then(parse_u256_hex)
            .unwrap_or(U256::ZERO);
        let gas_limit = raw.gas.as_deref().and_then(parse_u64_hex);
        let max_fee_per_gas = raw.max_fee_per_gas.as_deref().and_then(parse_u128_hex);
        let max_priority_fee_per_gas = raw
            .max_priority_fee_per_gas
            .as_deref()
            .and_then(parse_u128_hex);
        let from = raw.from.as_deref().and_then(parse_address);

        Some(MevShareHint {
            tx_hash,
            router,
            from,
            call_data,
            value,
            gas_limit,
            max_fee_per_gas,
            max_priority_fee_per_gas,
        })
    }
}

#[derive(Debug, Deserialize)]
struct HistoricalRecord {
    #[serde(rename = "hint")]
    hint: Option<RawEvent>,
}

#[cfg(test)]
mod tests {

    #[test]
    fn parses_null_txs_hint() {
        let json = r#"{"hash":"0xabc","txs":null}"#;
        let evt: RawEvent = serde_json::from_str(json).expect("parse");
        assert!(evt.txs.is_none());
    }

    #[test]
    fn parses_null_event_payload() {
        let evt: Option<RawEvent> = serde_json::from_str("null").expect("parse");
        assert!(evt.is_none());
    }
}

fn strip_0x(s: &str) -> &str {
    s.strip_prefix("0x").unwrap_or(s)
}

fn parse_hex_bytes(s: &str) -> Option<Vec<u8>> {
    hex::decode(strip_0x(s)).ok()
}

fn parse_b256(s: &str) -> Option<B256> {
    let bytes = parse_hex_bytes(s)?;
    if bytes.len() != 32 {
        return None;
    }
    Some(B256::from_slice(&bytes))
}

fn parse_address(s: &str) -> Option<Address> {
    Address::from_str(strip_0x(s)).ok()
}

fn parse_u256_hex(s: &str) -> Option<U256> {
    U256::from_str_radix(strip_0x(s), 16).ok()
}

fn parse_u128_hex(s: &str) -> Option<u128> {
    u128::from_str_radix(strip_0x(s), 16).ok()
}

fn parse_u64_hex(s: &str) -> Option<u64> {
    u64::from_str_radix(strip_0x(s), 16).ok()
}
//==================================================================================================
// END:   infrastructure/network/mev_share.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/network/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod gas;
pub mod mev_share;
pub mod price_feed;
pub mod provider;
//==================================================================================================
// END:   infrastructure/network/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/network/price_feed.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


const CACHE_TTL: u64 = 60; // Cache prices for 60 seconds

#[derive(Deserialize, Debug)]
struct BinanceTicker {
    #[allow(dead_code)]
    symbol: String,
    price: String,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct NormalizedSymbols {
    cache_key: String,
    chainlink_symbol: String,
    binance_symbols: Vec<String>,
}

#[derive(Clone)]
pub struct PriceFeed {
    client: Client,
    // Map: Symbol -> (Price, Timestamp)
    cache: Arc<RwLock<HashMap<String, (PriceQuote, Instant)>>>,
    chainlink_feeds: HashMap<String, Address>,
    provider: HttpProvider,
}

#[derive(Clone, Debug)]
pub struct PriceQuote {
    pub price: f64,
    pub source: String,
}

impl PriceFeed {
    pub fn new(provider: HttpProvider, chainlink_feeds: HashMap<String, Address>) -> Self {
        Self {
            client: Client::builder()
                .timeout(Duration::from_secs(5))
                .build()
                .unwrap(),
            cache: Arc::new(RwLock::new(HashMap::new())),
            chainlink_feeds,
            provider,
        }
    }

    /// Get price from Binance (e.g., symbol = "ETHUSDT")
    pub async fn get_price(&self, symbol: &str) -> Result<PriceQuote, AppError> {
        let normalized = normalize_symbol(symbol);

        // 1. Check Cache
        {
            let read_guard = self.cache.read().await;
            if let Some((quote, timestamp)) = read_guard.get(&normalized.cache_key) {
                if timestamp.elapsed().as_secs() < CACHE_TTL {
                    return Ok(quote.clone());
                }
            }
        }

        // 2. Try Chainlink on-chain feed
        if let Some(price) = self.try_chainlink(&normalized.chainlink_symbol).await? {
            self.store_cache(&normalized.cache_key, price.clone()).await;
            return Ok(price);
        }

        // 3. Fallback to Binance API
        let mut last_status = 0u16;
        for binance_symbol in &normalized.binance_symbols {
            let url = format!(
                "https://api.binance.com/api/v3/ticker/price?symbol={}",
                binance_symbol
            );
            let resp = match self.client.get(&url).send().await {
                Ok(r) => r,
                Err(_) => continue,
            };

            if !resp.status().is_success() {
                last_status = resp.status().as_u16();
                continue;
            }

            let ticker: BinanceTicker = resp.json().await.map_err(|_| AppError::ApiCall {
                provider: "Binance JSON".into(),
                status: 0,
            })?;

            let price = ticker.price.parse().unwrap_or(0.0);
            let quote = PriceQuote {
                price,
                source: "binance".into(),
            };

            self.store_cache(&normalized.cache_key, quote.clone()).await;

            return Ok(quote);
        }

        Err(AppError::ApiCall {
            provider: "Binance".into(),
            status: last_status,
        })
    }

    async fn try_chainlink(&self, symbol: &str) -> Result<Option<PriceQuote>, AppError> {
        let Some(addr) = self.chainlink_feeds.get(&symbol.to_uppercase()) else {
            return Ok(None);
        };

        sol! {
            #[derive(Debug, PartialEq, Eq)]
            #[sol(rpc)]
            contract AggregatorV3Interface {
                function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
                function decimals() external view returns (uint8);
            }
        }

        let contract = AggregatorV3Interface::new(*addr, self.provider.clone());
        let contract_for_decimals = contract.clone();
        let contract_for_latest = contract.clone();
        let decimals_resp: u8 = retry_async(
            move |_| {
                let c = contract_for_decimals.clone();
                async move { c.decimals().call().await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Chainlink decimals failed: {}", e)))?;
        let latest = retry_async(
            move |_| {
                let c = contract_for_latest.clone();
                async move { c.latestRoundData().call().await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Chainlink price failed: {}", e)))?;

        // Chainlink answers are int256; negative indicates invalid.
        if latest.answer.is_negative() {
            return Ok(None);
        }

        let decimals = decimals_resp as i32;
        let raw: i128 = latest
            .answer
            .try_into()
            .map_err(|e| AppError::Connection(format!("Chainlink answer convert failed: {}", e)))?;
        let price = (raw as f64) / 10f64.powi(decimals);
        Ok(Some(PriceQuote {
            price,
            source: "chainlink".into(),
        }))
    }

    async fn store_cache(&self, symbol: &str, price: PriceQuote) {
        let mut write_guard = self.cache.write().await;
        write_guard.insert(symbol.to_string(), (price, Instant::now()));
    }
}

fn normalize_symbol(symbol: &str) -> NormalizedSymbols {
    let cleaned: String = symbol
        .chars()
        .filter(|c| c.is_ascii_alphanumeric())
        .collect::<String>()
        .to_uppercase();

    let (base, explicit_quote) = strip_quote(&cleaned);
    let chainlink_symbol = alias_base(&base);

    let mut binance_symbols = Vec::new();
    if let Some(q) = explicit_quote {
        binance_symbols.push(format!("{}{}", chainlink_symbol, q));
    }

    // Prefer USDT/USDC, then USD/BUSD for breadth.
    for quote in ["USDT", "USDC", "USD", "BUSD"] {
        binance_symbols.push(format!("{}{}", chainlink_symbol, quote));
    }

    binance_symbols.sort();
    binance_symbols.dedup();

    NormalizedSymbols {
        cache_key: chainlink_symbol.clone(),
        chainlink_symbol,
        binance_symbols,
    }
}

fn strip_quote(symbol: &str) -> (String, Option<&'static str>) {
    const QUOTES: [&str; 4] = ["USDT", "USDC", "USD", "BUSD"];
    for quote in QUOTES {
        if let Some(base) = symbol.strip_suffix(quote) {
            return (base.to_string(), Some(quote));
        }
    }
    (symbol.to_string(), None)
}

fn alias_base(base: &str) -> String {
    match base {
        "WETH" => "ETH".into(),
        "WBTC" => "BTC".into(),
        _ => base.to_string(),
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn normalizes_ethusd() {
        let normalized = normalize_symbol("ethusd");
        assert_eq!(normalized.cache_key, "ETH");
        assert_eq!(normalized.chainlink_symbol, "ETH");
        assert!(normalized.binance_symbols.contains(&"ETHUSDT".to_string()));
    }

    #[test]
    fn normalizes_plain_symbol() {
        let normalized = normalize_symbol("eth");
        assert_eq!(normalized.cache_key, "ETH");
        assert!(normalized.binance_symbols.contains(&"ETHUSDT".to_string()));
    }

    #[test]
    fn normalizes_with_alias_and_separator() {
        let normalized = normalize_symbol("weth-usdc");
        assert_eq!(normalized.chainlink_symbol, "ETH");
        assert!(normalized.binance_symbols.contains(&"ETHUSDC".to_string()));
        assert!(normalized.binance_symbols.contains(&"ETHUSDT".to_string()));
    }
}
//==================================================================================================
// END:   infrastructure/network/price_feed.rs
//==================================================================================================

//==================================================================================================
// BEGIN: infrastructure/network/provider.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub type HttpProvider = RootProvider<Ethereum>;
pub type WsProvider = RootProvider<Ethereum>;
pub type IpcProvider = RootProvider<Ethereum>;

pub struct ConnectionFactory;

impl ConnectionFactory {
    pub fn http(rpc_url: &str) -> Result<HttpProvider, AppError> {
        let url =
            Url::parse(rpc_url).map_err(|e| AppError::Config(format!("Invalid RPC URL: {}", e)))?;

        let provider = RootProvider::new_http(url);
        Ok(provider)
    }

    pub async fn ws(ws_url: &str) -> Result<WsProvider, AppError> {
        let provider = RootProvider::connect(ws_url)
            .await
            .map_err(|e| AppError::Connection(format!("WS Connection failed: {}", e)))?;

        Ok(provider)
    }

    pub async fn ipc(ipc_url: &str) -> Result<IpcProvider, AppError> {
        let path = PathBuf::from(ipc_url);
        let conn = BuiltInConnectionString::Ipc(path);
        let provider: IpcProvider = RootProvider::connect_with(conn)
            .await
            .map_err(|e| AppError::Connection(format!("IPC Connection failed: {}", e)))?;

        Ok(provider)
    }
}
//==================================================================================================
// END:   infrastructure/network/provider.rs
//==================================================================================================

//==================================================================================================
// BEGIN: lib.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod app;
pub mod common;
pub mod domain;
pub mod infrastructure;
pub mod services;

// Backward-compat re-exports
//==================================================================================================
// END:   lib.rs
//==================================================================================================

//==================================================================================================
// BEGIN: main.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Parser, Debug)]
#[command(author, version, about = "Oxidity Builder")]
struct Cli {
    /// Path to config file (default: config.{toml,yaml,...})
    #[arg(long)]
    config: Option<String>,

    /// Do not submit transactions/bundles, only simulate/log
    #[arg(long, default_value_t = false)]
    dry_run: bool,

    /// Metrics port (overrides config/env)
    #[arg(long)]
    metrics_port: Option<u16>,

    /// Disable strategies (ingest only)
    #[arg(long, default_value_t = true)]
    strategy_enabled: bool,

    /// Slippage basis points for crafted bundles
    #[arg(long)]
    slippage_bps: Option<u64>,
}

#[tokio::main]
async fn main() -> Result<(), AppError> {
    let cli = Cli::parse();

    let settings = GlobalSettings::load_with_path(cli.config.as_deref())?;
    setup_logging(if settings.debug { "debug" } else { "info" }, false);

    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "sqlite://oxidity_builder.db".to_string());
    let db = Database::new(&database_url).await?;

    let chain_id = *settings.chains.get(0).unwrap_or(&1);

    let ipc_url = settings.get_ipc_url(chain_id);
    let (ws_provider, http_provider) = match ipc_url {
        Some(ipc_url) => match ConnectionFactory::ipc(&ipc_url).await {
            Ok(ipc_provider) => {
                tracing::info!(target: "rpc", %ipc_url, "Using IPC provider");
                (ipc_provider.clone(), ipc_provider)
            }
            Err(e) => {
                tracing::warn!(
                    target: "rpc",
                    %ipc_url,
                    error = %e,
                    "IPC connection failed; falling back to WS/HTTP"
                );
                let ws_url = settings.get_ws_url(chain_id)?;
                let ws_provider = ConnectionFactory::ws(&ws_url).await?;
                let rpc_url = settings.get_rpc_url(chain_id)?;
                let http_provider = ConnectionFactory::http(&rpc_url)?;
                (ws_provider, http_provider)
            }
        },
        None => {
            let ws_url = settings.get_ws_url(chain_id)?;
            let ws_provider = ConnectionFactory::ws(&ws_url).await?;
            let rpc_url = settings.get_rpc_url(chain_id)?;
            let http_provider = ConnectionFactory::http(&rpc_url)?;
            (ws_provider, http_provider)
        }
    };

    let wallet_address = settings.wallet_address;
    let portfolio = Arc::new(PortfolioManager::new(http_provider.clone(), wallet_address));
    let nonce_manager = NonceManager::new(http_provider.clone(), wallet_address);
    let safety_guard = Arc::new(SafetyGuard::new());
    let gas_oracle = GasOracle::new(http_provider.clone());

    let chainlink_feeds = settings.chainlink_feeds_for_chain(chain_id)?;
    if chainlink_feeds.is_empty() {
        tracing::warn!("No Chainlink feeds configured for chain {}", chain_id);
    }
    let wrapped_native = oxidity_builder::common::constants::wrapped_native_for_chain(chain_id);
    let price_feed = PriceFeed::new(http_provider.clone(), chainlink_feeds);
    let simulator = Simulator::new(http_provider.clone());
    let tokenlist_path = settings.tokenlist_path();
    let token_manager = Arc::new(
        TokenManager::load_from_file(&tokenlist_path).unwrap_or_else(|e| {
            tracing::warn!(
                "TokenManager: failed to load {}; defaulting to empty list: {}",
                tokenlist_path,
                e
            );
            TokenManager::default()
        }),
    );

    let relay_url = settings.flashbots_relay_url();
    let bundle_signer = PrivateKeySigner::from_str(&settings.bundle_signer_key())
        .map_err(|e| AppError::Config(format!("Invalid bundle signer key: {}", e)))?;
    let metrics_port: u16 = cli
        .metrics_port
        .or_else(|| {
            std::env::var("METRICS_PORT")
                .ok()
                .and_then(|s| s.parse().ok())
        })
        .unwrap_or(settings.metrics_port);
    let slippage_bps = cli.slippage_bps.unwrap_or(settings.slippage_bps);
    let strategy_enabled = cli.strategy_enabled && settings.strategy_enabled;
    let router_allowlist: HashSet<Address> = settings
        .routers_for_chain(chain_id)?
        .values()
        .copied()
        .collect();
    if router_allowlist.is_empty() {
        tracing::warn!("Router allowlist is empty for chain {}", chain_id);
    }

    let engine = Engine::new(
        http_provider,
        ws_provider,
        db,
        nonce_manager,
        portfolio,
        safety_guard,
        cli.dry_run,
        gas_oracle,
        price_feed,
        chain_id,
        relay_url,
        bundle_signer,
        settings.executor_address,
        settings.executor_bribe_bps,
        settings.executor_bribe_recipient,
        settings.flashloan_enabled,
        settings
            .gas_cap_for_chain(chain_id)
            .unwrap_or(settings.max_gas_price_gwei),
        simulator,
        token_manager,
        metrics_port,
        strategy_enabled,
        slippage_bps,
        router_allowlist,
        wrapped_native,
        settings.mev_share_stream_url.clone(),
        settings.mev_share_history_limit,
        settings.mev_share_enabled,
    );

    engine.run().await
}
//==================================================================================================
// END:   main.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/metrics.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub async fn spawn_metrics_server(
    port: u16,
    stats: Arc<StrategyStats>,
    portfolio: Arc<PortfolioManager>,
) -> Option<SocketAddr> {
    let addr = SocketAddr::from(([0, 0, 0, 0], port));
    let listener = match TcpListener::bind(addr).await {
        Ok(l) => l,
        Err(e) => {
            tracing::warn!("Metrics server failed to bind: {}", e);
            return None;
        }
    };

    let local = listener.local_addr().ok();
    if let Some(addr) = local {
        tracing::info!("Metrics server listening on {}", addr);
    }

    tokio::spawn(async move {
        loop {
            match listener.accept().await {
                Ok((mut socket, _)) => {
                    // Very small HTTP parser to switch between Prometheus text and JSON dashboard payloads.
                    let mut buf = [0u8; 1024];
                    let n = socket.read(&mut buf).await.unwrap_or(0);
                    let req = String::from_utf8_lossy(&buf[..n]).to_string();
                    let path = req
                        .lines()
                        .next()
                        .and_then(|l| l.split_whitespace().nth(1))
                        .unwrap_or("/");
                    let (route, query) = path.split_once('?').unwrap_or((path, ""));

                    if route.starts_with("/dashboard") {
                        let body = render_dashboard_json(&stats, &portfolio);
                        let response = format!(
                            "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\n\r\n{}",
                            body.len(),
                            body
                        );
                        let _ = socket.write_all(response.as_bytes()).await;
                    } else if route.starts_with("/bundles") {
                        // Placeholder bundle payload; extend when bundle history is persisted.
                        let body = r#"{"history":[],"table":[]}"#;
                        let response = format!(
                            "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\n\r\n{}",
                            body.len(),
                            body
                        );
                        let _ = socket.write_all(response.as_bytes()).await;
                    } else if route.starts_with("/logs") {
                        let logs = recent_logs(200);
                        let body = serde_json::to_string(&logs).unwrap_or_else(|_| "[]".to_string());
                        let response = format!(
                            "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\n\r\n{}",
                            body.len(),
                            body
                        );
                        let _ = socket.write_all(response.as_bytes()).await;
                    } else if route.starts_with("/log_level") {
                        let level = query.split('&').find_map(|kv| {
                            let mut parts = kv.split('=');
                            match (parts.next(), parts.next()) {
                                (Some("level"), Some(v)) => Some(v),
                                _ => None,
                            }
                        });

                        let (status, body) = match level {
                            Some(lvl) => match set_log_level(lvl) {
                                Ok(_) => ("200 OK", json!({"status": "ok", "level": lvl}).to_string()),
                                Err(e) => ("400 Bad Request", json!({"status": "error", "error": e}).to_string()),
                            },
                            None => ("400 Bad Request", json!({"status": "error", "error": "missing level"}).to_string()),
                        };

                        let response = format!(
                            "HTTP/1.1 {}\r\nContent-Type: application/json\r\nContent-Length: {}\r\n\r\n{}",
                            status,
                            body.len(),
                            body
                        );
                        let _ = socket.write_all(response.as_bytes()).await;
                    } else {
                        let body = render_metrics(&stats, &portfolio);
                        let response = format!(
                            "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: {}\r\n\r\n{}",
                            body.len(),
                            body
                        );
                        let _ = socket.write_all(response.as_bytes()).await;
                    }
                }
                Err(e) => {
                    tracing::warn!("Metrics accept error: {}", e);
                    continue;
                }
            }
        }
    });

    local
}

fn render_metrics(stats: &Arc<StrategyStats>, portfolio: &Arc<PortfolioManager>) -> String {
    let processed = stats.processed.load(std::sync::atomic::Ordering::Relaxed);
    let submitted = stats.submitted.load(std::sync::atomic::Ordering::Relaxed);
    let skipped = stats.skipped.load(std::sync::atomic::Ordering::Relaxed);
    let failed = stats.failed.load(std::sync::atomic::Ordering::Relaxed);
    let mut body = format!(
        concat!(
            "# TYPE strategy_processed counter\nstrategy_processed {}\n",
            "# TYPE strategy_submitted counter\nstrategy_submitted {}\n",
            "# TYPE strategy_skipped counter\nstrategy_skipped {}\n",
            "# TYPE strategy_failed counter\nstrategy_failed {}\n"
        ),
        processed, submitted, skipped, failed
    );

    for (chain, profit) in portfolio.net_profit_all() {
        body.push_str(&format!(
            "# TYPE net_profit_eth gauge\nnet_profit_eth{{chain=\"{}\"}} {}\n",
            chain, profit
        ));
    }

    for (chain, token, profit) in portfolio.token_profit_all() {
        body.push_str(&format!(
            "# TYPE token_profit gauge\ntoken_profit{{chain=\"{}\",token=\"{:#x}\"}} {}\n",
            chain, token, profit
        ));
    }

    body
}

fn render_dashboard_json(stats: &Arc<StrategyStats>, portfolio: &Arc<PortfolioManager>) -> String {
    let processed = stats.processed.load(std::sync::atomic::Ordering::Relaxed);
    let submitted = stats.submitted.load(std::sync::atomic::Ordering::Relaxed);
    let skipped = stats.skipped.load(std::sync::atomic::Ordering::Relaxed);
    let failed = stats.failed.load(std::sync::atomic::Ordering::Relaxed);
    let success_rate = if submitted > 0 {
        ((submitted.saturating_sub(failed)) as f64) / (submitted as f64) * 100.0
    } else {
        0.0
    };

    let mut net_profit_by_chain = serde_json::Map::new();
    let mut total_profit = 0.0;
    for (chain, profit) in portfolio.net_profit_all() {
        total_profit += profit;
        net_profit_by_chain.insert(chain.to_string(), serde_json::json!(profit));
    }

    let mut token_profit = Vec::new();
    for (chain, token, profit) in portfolio.token_profit_all() {
        token_profit.push(serde_json::json!({
            "chain": chain.to_string(),
            "token": format!("{:#x}", token),
            "profit": profit
        }));
    }

    let payload = serde_json::json!({
        "processed": processed,
        "submitted": submitted,
        "skipped": skipped,
        "failed": failed,
        "successRate": success_rate,
        "netProfitEth": total_profit,
        "netProfitByChain": net_profit_by_chain,
        "tokenProfit": token_profit,
        "history": [], // reserved for future bundle history wiring
        "table": []    // reserved for future bundle table wiring
    });

    payload.to_string()
}

#[cfg(test)]
mod tests {

    #[tokio::test]
    async fn metrics_endpoint_serves() {
        let provider = HttpProvider::new_http(Url::parse("http://localhost:8545").unwrap());
        let portfolio = Arc::new(PortfolioManager::new(provider, Address::ZERO));
        let stats = Arc::new(StrategyStats::default());

        let addr = spawn_metrics_server(0, stats.clone(), portfolio.clone())
            .await
            .expect("bind metrics");

        let body = reqwest::get(format!("http://{}", addr))
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        assert!(body.contains("strategy_processed"));
    }
}
//==================================================================================================
// END:   services/metrics.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod metrics;
pub mod strategy;
//==================================================================================================
// END:   services/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/block_listener.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub struct BlockListener {
    provider: WsProvider,
    broadcaster: Sender<Header>,
    nonce_manager: NonceManager,
}

impl BlockListener {
    pub fn new(
        provider: WsProvider,
        broadcaster: Sender<Header>,
        nonce_manager: NonceManager,
    ) -> Self {
        Self {
            provider,
            broadcaster,
            nonce_manager,
        }
    }

    pub async fn run(self) -> Result<(), AppError> {
        tracing::info!("BlockListener: subscribing to newHeads");
        let mut last_hash: Option<alloy::primitives::B256> = None;
        loop {
            match self.provider.subscribe_blocks().await {
                Ok(sub) => {
                    let mut stream = sub.into_stream();
                    tracing::info!("BlockListener: subscribed to newHeads");
                    while let Some(header) = stream.next().await {
                        let _ = self.broadcaster.send(header.clone());

                        if let Err(e) = self.nonce_manager.resync().await {
                            tracing::warn!("Nonce resync failed on new block: {}", e);
                        }

                        tracing::debug!(
                            "New head received: number={:?} hash={:?}",
                            header.inner.number,
                            header.hash
                        );
                    }
                    tracing::warn!("BlockListener: subscription ended, retrying after backoff");
                }
                Err(e) => {
                    tracing::warn!("Block subscription failed ({}); falling back to polling", e);
                    self.poll_once(&mut last_hash).await;
                }
            }
            sleep(Duration::from_secs(2)).await;
        }
    }

    async fn poll_once(&self, last_hash: &mut Option<alloy::primitives::B256>) {
        match self
            .provider
            .get_block_by_number(BlockNumberOrTag::Latest)
            .await
        {
            Ok(Some(block)) => {
                let hash = block.header.hash;
                if last_hash.map(|h| h != hash).unwrap_or(true) {
                    *last_hash = Some(hash);
                    let header = block.header;
                    let _ = self.broadcaster.send(header.clone());
                    if let Err(e) = self.nonce_manager.resync().await {
                        tracing::warn!("Nonce resync failed on new block: {}", e);
                    }
                }
            }
            Ok(None) => {
                tracing::debug!("Polling block returned None");
            }
            Err(e) => {
                tracing::warn!("Polling latest block failed: {}", e);
            }
        }
    }
}
//==================================================================================================
// END:   services/strategy/block_listener.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/engine.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub struct Engine {
    http_provider: HttpProvider,
    ws_provider: WsProvider,
    db: Database,
    nonce_manager: NonceManager,
    portfolio: Arc<PortfolioManager>,
    safety_guard: Arc<SafetyGuard>,
    dry_run: bool,
    gas_oracle: GasOracle,
    price_feed: PriceFeed,
    chain_id: u64,
    relay_url: String,
    bundle_signer: PrivateKeySigner,
    executor: Option<Address>,
    executor_bribe_bps: u64,
    executor_bribe_recipient: Option<Address>,
    flashloan_enabled: bool,
    max_gas_price_gwei: u64,
    simulator: Simulator,
    token_manager: Arc<TokenManager>,
    metrics_port: u16,
    strategy_enabled: bool,
    slippage_bps: u64,
    router_allowlist: HashSet<Address>,
    wrapped_native: Address,
    mev_share_stream_url: String,
    mev_share_history_limit: u32,
    mev_share_enabled: bool,
}

impl Engine {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        http_provider: HttpProvider,
        ws_provider: WsProvider,
        db: Database,
        nonce_manager: NonceManager,
        portfolio: Arc<PortfolioManager>,
        safety_guard: Arc<SafetyGuard>,
        dry_run: bool,
        gas_oracle: GasOracle,
        price_feed: PriceFeed,
        chain_id: u64,
        relay_url: String,
        bundle_signer: PrivateKeySigner,
        executor: Option<Address>,
        executor_bribe_bps: u64,
        executor_bribe_recipient: Option<Address>,
        flashloan_enabled: bool,
        max_gas_price_gwei: u64,
        simulator: Simulator,
        token_manager: Arc<TokenManager>,
        metrics_port: u16,
        strategy_enabled: bool,
        slippage_bps: u64,
        router_allowlist: HashSet<Address>,
        wrapped_native: Address,
        mev_share_stream_url: String,
        mev_share_history_limit: u32,
        mev_share_enabled: bool,
    ) -> Self {
        Self {
            http_provider,
            ws_provider,
            db,
            nonce_manager,
            portfolio,
            safety_guard,
            dry_run,
            gas_oracle,
            price_feed,
            chain_id,
            relay_url,
            bundle_signer,
            executor,
            executor_bribe_bps,
            executor_bribe_recipient,
            flashloan_enabled,
            max_gas_price_gwei,
            simulator,
            token_manager,
            metrics_port,
            strategy_enabled,
            slippage_bps,
            router_allowlist,
            wrapped_native,
            mev_share_stream_url,
            mev_share_history_limit,
            mev_share_enabled,
        }
    }

    pub async fn run(self) -> Result<(), AppError> {
        let (tx_sender, tx_receiver) = mpsc::unbounded_channel();
        let (block_sender, block_receiver) = broadcast::channel(32);

        let mempool = MempoolScanner::new(self.ws_provider.clone(), tx_sender.clone());
        let block_listener = BlockListener::new(
            self.ws_provider.clone(),
            block_sender.clone(),
            self.nonce_manager.clone(),
        );
        let bundle_sender: SharedBundleSender = Arc::new(BundleSender::new(
            self.http_provider.clone(),
            self.dry_run,
            self.relay_url.clone(),
            self.bundle_signer.clone(),
        ));
        let stats = Arc::new(StrategyStats::default());
        let _metrics_addr = crate::common::metrics::spawn_metrics_server(
            self.metrics_port,
            stats.clone(),
            self.portfolio.clone(),
        )
        .await;
        if self.strategy_enabled {
            let strategy = StrategyExecutor::new(
                tx_receiver,
                block_receiver,
                self.safety_guard.clone(),
                bundle_sender.clone(),
                self.db.clone(),
                self.portfolio.clone(),
                self.gas_oracle.clone(),
                self.price_feed,
                self.chain_id,
                self.max_gas_price_gwei,
                self.simulator,
                self.token_manager.clone(),
                stats,
                self.bundle_signer.clone(),
                self.nonce_manager.clone(),
                self.slippage_bps,
                self.http_provider.clone(),
                self.dry_run,
                self.router_allowlist.clone(),
                self.wrapped_native,
                self.executor,
                self.executor_bribe_bps,
                self.executor_bribe_recipient,
                self.flashloan_enabled,
            );

            if self.mev_share_enabled {
                let mev_share = MevShareClient::new(
                    self.mev_share_stream_url.clone(),
                    self.chain_id,
                    tx_sender.clone(),
                    self.mev_share_history_limit,
                );
                tokio::try_join!(
                    mempool.run(),
                    block_listener.run(),
                    strategy.run(),
                    mev_share.run()
                )
                .map(|_| ())
                .map_err(|e| AppError::Unknown(e.into()))
            } else {
                tokio::try_join!(mempool.run(), block_listener.run(), strategy.run())
                    .map(|_| ())
                    .map_err(|e| AppError::Unknown(e.into()))
            }
        } else {
            tokio::try_join!(mempool.run(), block_listener.run())
                .map(|_| ())
                .map_err(|e| AppError::Unknown(e.into()))
        }
    }
}
//==================================================================================================
// END:   services/strategy/engine.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/executor.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Clone, Debug, Serialize)]
#[serde(untagged)]
pub enum BundleItem {
    Hash {
        hash: String,
    },
    Tx {
        tx: String,
        #[serde(rename = "canRevert")]
        can_revert: bool,
    },
}

/// Sends bundles or raw transactions to the network/relays.
pub struct BundleSender {
    provider: HttpProvider,
    dry_run: bool,
    relay_url: String,
    signer: PrivateKeySigner,
}

impl BundleSender {
    pub fn new(
        provider: HttpProvider,
        dry_run: bool,
        relay_url: String,
        signer: PrivateKeySigner,
    ) -> Self {
        Self {
            provider,
            dry_run,
            relay_url,
            signer,
        }
    }

    /// Send a MEV-Share bundle that references tx hashes (instead of raw bytes).
    pub async fn send_mev_share_bundle(&self, body: &[BundleItem]) -> Result<(), AppError> {
        if self.dry_run {
            tracing::info!(target: "executor", "Dry-run: would send mev_sendBundle with {} legs", body.len());
            return Ok(());
        }

        let block_number =
            self.provider.get_block_number().await.map_err(|e| {
                AppError::Connection(format!("Failed to fetch block number: {}", e))
            })?;
        let params = json!({
            "version": "v0.1",
            "inclusion": {
                "block": format!("0x{:x}", block_number + 1),
                "maxBlock": format!("0x{:x}", block_number + 4),
            },
            "body": body,
            "privacy": {
                "builders": ["flashbots", "beaverbuild.org", "rsync", "titan"]
            }
        });

        let payload = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "mev_sendBundle",
            "params": [params]
        });

        let body_bytes =
            serde_json::to_vec(&payload).map_err(|e| AppError::Initialization(e.to_string()))?;
        let sig_header = self.sign_request(&body_bytes)?;

        let client = reqwest::Client::new();
        let mut attempts = 0;
        loop {
            attempts += 1;
            let resp = client
                .post(&self.relay_url)
                .header("Content-Type", "application/json")
                .header(
                    "X-Flashbots-Signature",
                    HeaderValue::from_str(&sig_header).map_err(|e| {
                        AppError::Connection(format!("Signature header invalid: {}", e))
                    })?,
                )
                .body(body_bytes.clone())
                .send()
                .await
                .map_err(|e| AppError::Connection(format!("Relay POST failed: {}", e)))?;

            let status = resp.status();
            let body_text = resp.text().await.unwrap_or_default();
            if status.is_success() {
                tracing::info!(target: "executor", relay=%self.relay_url, block=block_number + 1, legs=body.len(), body=%body_text, "MEV-Share bundle submitted");
                break;
            } else if attempts < 2 {
                tracing::warn!(target: "executor", status=%status, body=%body_text, attempt=attempts, "Relay rejected mev_sendBundle, retrying");
                continue;
            } else {
                return Err(AppError::Connection(format!(
                    "Relay rejected mev_sendBundle: {} body={}",
                    status, body_text
                )));
            }
        }

        Ok(())
    }

    /// Broadcast a list of raw transaction payloads (RLP encoded).
    /// In dry-run mode this only logs.
    pub async fn send_bundle(&self, raw_txs: &[Vec<u8>], chain_id: u64) -> Result<(), AppError> {
        if self.dry_run {
            tracing::info!("Dry-run: would send bundle with {} txs", raw_txs.len());
            return Ok(());
        }

        if chain_id == 1 {
            self.send_mainnet_builders(raw_txs).await
        } else {
            self.send_direct(raw_txs).await
        }
    }

    async fn send_direct(&self, raw_txs: &[Vec<u8>]) -> Result<(), AppError> {
        for raw in raw_txs {
            let mut attempts = 0;
            loop {
                attempts += 1;
                let res = self.provider.send_raw_transaction(raw.as_slice()).await;
                match res {
                    Ok(_) => break,
                    Err(e) if attempts < 2 => {
                        tracing::warn!(target: "executor", error=%e, attempt=attempts, "Retrying raw tx send");
                        continue;
                    }
                    Err(e) => {
                        return Err(AppError::Connection(format!("Bundle send failed: {}", e)));
                    }
                }
            }
        }
        Ok(())
    }

    async fn send_mainnet_builders(&self, raw_txs: &[Vec<u8>]) -> Result<(), AppError> {
        let block_number =
            self.provider.get_block_number().await.map_err(|e| {
                AppError::Connection(format!("Failed to fetch block number: {}", e))
            })?;
        let target_block = block_number + 1;
        let params = json!({
            "txs": raw_txs.iter().map(|r| format!("0x{}", hex::encode(r))).collect::<Vec<_>>(),
            "blockNumber": format!("0x{:x}", target_block),
            "minTimestamp": current_unix(),
        });

        let body = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "eth_sendBundle",
            "params": [params]
        });

        let body_bytes =
            serde_json::to_vec(&body).map_err(|e| AppError::Initialization(e.to_string()))?;

        // Primary: Flashbots relay (signed header)
        self.post_bundle_with_sig(
            &self.relay_url,
            &body_bytes,
            "flashbots",
            target_block,
            raw_txs.len(),
        )
        .await?;

        // Secondary: beaver (no auth) and titan (signed best-effort)
        let secondary = [
            ("https://rpc.beaverbuild.org", false, "beaver"),
            ("https://rpc.titanbuilder.xyz", true, "titan"),
        ];
        for (url, with_sig, name) in secondary {
            if let Err(e) = self
                .post_bundle_optional(
                    url,
                    &body_bytes,
                    with_sig,
                    name,
                    target_block,
                    raw_txs.len(),
                )
                .await
            {
                tracing::warn!(target: "executor", relay=%url, error=%e, "Secondary builder submit failed");
            }
        }

        Ok(())
    }

    async fn post_bundle_with_sig(
        &self,
        url: &str,
        body_bytes: &[u8],
        name: &str,
        target_block: u64,
        txs: usize,
    ) -> Result<(), AppError> {
        let sig_header = self.sign_request(body_bytes)?;
        let client = reqwest::Client::new();
        let mut attempts = 0;
        loop {
            attempts += 1;
            let resp = client
                .post(url)
                .header("Content-Type", "application/json")
                .header(
                    "X-Flashbots-Signature",
                    HeaderValue::from_str(&sig_header).map_err(|e| {
                        AppError::Connection(format!("Signature header invalid: {}", e))
                    })?,
                )
                .body(body_bytes.to_vec())
                .send()
                .await
                .map_err(|e| AppError::Connection(format!("Relay POST failed: {}", e)))?;

            let status = resp.status();
            let body_text = resp.text().await.unwrap_or_default();
            if status.is_success() {
                tracing::info!(target: "executor", relay=%url, name=%name, block=target_block, txs=txs, body=%body_text, "Bundle submitted");
                return Ok(());
            } else if attempts < 2 {
                tracing::warn!(target: "executor", relay=%url, status=%status, body=%body_text, attempt=attempts, "Relay rejected bundle, retrying");
                continue;
            } else {
                return Err(AppError::Connection(format!(
                    "Relay {} rejected bundle: {} body={}",
                    name, status, body_text
                )));
            }
        }
    }

    async fn post_bundle_optional(
        &self,
        url: &str,
        body_bytes: &[u8],
        with_sig: bool,
        name: &str,
        target_block: u64,
        txs: usize,
    ) -> Result<(), AppError> {
        if with_sig {
            return self
                .post_bundle_with_sig(url, body_bytes, name, target_block, txs)
                .await;
        }

        let client = reqwest::Client::new();
        let resp = client
            .post(url)
            .header("Content-Type", "application/json")
            .body(body_bytes.to_vec())
            .send()
            .await
            .map_err(|e| AppError::Connection(format!("Relay POST failed: {}", e)))?;

        let status = resp.status();
        let body_text = resp.text().await.unwrap_or_default();
        if status.is_success() {
            tracing::info!(target: "executor", relay=%url, name=%name, block=target_block, txs=txs, body=%body_text, "Bundle submitted (best-effort)");
            Ok(())
        } else {
            Err(AppError::Connection(format!(
                "Relay {} rejected bundle: {} body={}",
                name, status, body_text
            )))
        }
    }

    fn sign_request(&self, body_bytes: &[u8]) -> Result<String, AppError> {
        let hash = keccak256(body_bytes);
        let sig = self
            .signer
            .sign_hash_sync(&hash)
            .map_err(|e| AppError::Connection(format!("Bundle signing failed: {}", e)))?;
        let sig_hex = format!("0x{}", hex::encode(sig.as_bytes()));
        Ok(format!("{:#x}:{}", self.signer.address(), sig_hex))
    }
}

pub type SharedBundleSender = Arc<BundleSender>;

fn current_unix() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
}
//==================================================================================================
// END:   services/strategy/executor.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/mempool.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub struct MempoolScanner {
    provider: WsProvider,
    tx_sender: UnboundedSender<StrategyWork>,
}

impl MempoolScanner {
    pub fn new(provider: WsProvider, tx_sender: UnboundedSender<StrategyWork>) -> Self {
        Self {
            provider,
            tx_sender,
        }
    }

    pub async fn run(self) -> Result<(), AppError> {
        tracing::info!("Mempool Scanner started...");

        loop {
            match self.provider.subscribe_full_pending_transactions().await {
                Ok(sub) => {
                    tracing::info!(target: "mempool", "Subscribed to full pendingTransactions");
                    let mut stream = sub.into_stream();
                    while let Some(tx) = stream.next().await {
                        if tx.input().len() > 4 {
                            let _ = self.tx_sender.send(StrategyWork::Mempool(tx));
                        }
                    }
                    tracing::warn!(target: "mempool", "Pending tx subscription ended, retrying after backoff");
                }
                Err(e) => {
                    tracing::warn!(
                        target: "mempool",
                        error = %e,
                        "WS pending sub failed; falling back to polling filter"
                    );
                    self.poll_filter_loop().await?;
                }
            }

            sleep(Duration::from_secs(2)).await;
        }
    }
}

impl MempoolScanner {
    async fn poll_filter_loop(&self) -> Result<(), AppError> {
        let filter_id = self
            .provider
            .new_pending_transactions_filter(true)
            .await
            .map_err(|err| AppError::Connection(format!("Filter create failed: {}", err)))?;

        loop {
            match self.provider.get_filter_changes::<Transaction>(filter_id).await {
                Ok(txs) => {
                    for tx in txs {
                        if tx.input().len() > 4 {
                            let _ = self.tx_sender.send(StrategyWork::Mempool(tx));
                        }
                    }
                }
                Err(err) => {
                    tracing::warn!(
                        target: "mempool",
                        error = %err,
                        "poll get_filter_changes failed"
                    );
                    break;
                }
            }
            sleep(Duration::from_millis(1200)).await;
        }

        Ok(())
    }
}
//==================================================================================================
// END:   services/strategy/mempool.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/mod.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

pub mod block_listener;
pub mod engine;
pub mod executor;
pub mod mempool;
pub mod nonce;
pub mod portfolio;
pub mod safety;
pub mod simulation;
pub mod strategy;
//==================================================================================================
// END:   services/strategy/mod.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/nonce.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Clone)]
pub struct NonceManager {
    provider: HttpProvider,
    address: Address,
}

impl NonceManager {
    pub fn new(provider: HttpProvider, address: Address) -> Self {
        Self {
            provider,
            address,
        }
    }

    pub async fn get_next_nonce(&self) -> Result<u64, AppError> {
        let provider = self.provider.clone();
        let address = self.address;
        let on_chain_nonce: u64 = retry_async(
            move |_| {
                let provider = provider.clone();
                async move { provider.get_transaction_count(address).await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Failed to fetch nonce: {}", e)))?;

        Ok(on_chain_nonce)
    }

    pub async fn resync(&self) -> Result<(), AppError> {
        let provider = self.provider.clone();
        let address = self.address;
        let on_chain_nonce: u64 = retry_async(
            move |_| {
                let provider = provider.clone();
                async move { provider.get_transaction_count(address).await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Failed to resync nonce: {}", e)))?;

        tracing::info!("Nonce resynced to {}", on_chain_nonce);
        Ok(())
    }
}
//==================================================================================================
// END:   services/strategy/nonce.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/portfolio.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Debug, Clone, Copy, PartialEq)]
pub enum BalanceTier {
    Emergency, // < 0.01 ETH
    Low,       // < 0.05 ETH
    Medium,    // < 1.0 ETH
    Healthy,   // Normal
    Whale,     // > 5.0 ETH
}

pub struct PortfolioManager {
    provider: HttpProvider,
    wallet_address: Address,

    // Cache current on-chain balances
    token_balances: DashMap<(u64, Address), U256>,
    eth_balance: DashMap<u64, U256>,

    // Metrics: Track Profit & Loss in Signed Wei (I256) to handle negative PnL accurately
    net_pnl_wei: DashMap<u64, I256>,
    total_gas_spent_wei: DashMap<u64, U256>,

    // Token profit in signed integer amounts
    token_profit_wei: DashMap<(u64, Address), I256>,
}

impl PortfolioManager {
    pub fn new(provider: HttpProvider, wallet_address: Address) -> Self {
        Self {
            provider,
            wallet_address,
            token_balances: DashMap::new(),
            eth_balance: DashMap::new(),
            net_pnl_wei: DashMap::new(),
            total_gas_spent_wei: DashMap::new(),
            token_profit_wei: DashMap::new(),
        }
    }

    pub async fn update_eth_balance(&self, chain_id: u64) -> Result<U256, AppError> {
        let provider = self.provider.clone();
        let addr = self.wallet_address;
        let bal = retry_async(
            move |_| {
                let provider = provider.clone();
                async move { provider.get_balance(addr).await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Balance check failed: {}", e)))?;

        self.eth_balance.insert(chain_id, bal);
        Ok(bal)
    }

    pub fn get_tier(&self, chain_id: u64) -> BalanceTier {
        let bal = self
            .eth_balance
            .get(&chain_id)
            .map(|v| *v)
            .unwrap_or(U256::ZERO);

        let emergency = U256::from(10_000_000_000_000_000u64); // 0.01 ETH
        let whale = U256::from(5_000_000_000_000_000_000u64); // 5.0 ETH

        if bal < emergency {
            BalanceTier::Emergency
        } else if bal < *LOW_BALANCE_THRESHOLD_WEI {
            BalanceTier::Low
        } else if bal > whale {
            BalanceTier::Whale
        } else {
            BalanceTier::Healthy
        }
    }

    pub fn ensure_funding(&self, chain_id: u64, amount_needed: U256) -> Result<(), AppError> {
        let bal = self
            .eth_balance
            .get(&chain_id)
            .map(|v| *v)
            .unwrap_or(U256::ZERO);
        let gas_reserve = U256::from(10_000_000_000_000_000u64); // 0.01 ETH Safety Buffer

        if bal < amount_needed.saturating_add(gas_reserve) {
            return Err(AppError::InsufficientFunds {
                required: amount_needed.to_string(),
                available: bal.to_string(),
            });
        }
        Ok(())
    }

    pub async fn update_token_balance(
        &self,
        chain_id: u64,
        token: Address,
    ) -> Result<U256, AppError> {
        alloy::sol! {
            #[derive(Debug, PartialEq, Eq)]
            #[sol(rpc)]
            contract ERC20 {
                function balanceOf(address) external view returns (uint256);
            }
        }

        let contract = ERC20::new(token, self.provider.clone());
        let bal: U256 = retry_async(
            move |_| {
                let contract = contract.clone();
                async move { contract.balanceOf(self.wallet_address).call().await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Connection(format!("Token balance failed: {}", e)))?;

        self.token_balances.insert((chain_id, token), bal);
        Ok(bal)
    }

    pub fn get_token_balance(&self, chain_id: u64, token: Address) -> U256 {
        self.token_balances
            .get(&(chain_id, token))
            .map(|v| *v)
            .unwrap_or(U256::ZERO)
    }

    /// Record a completed trade.
    /// Takes raw Wei (U256) for revenue and cost to avoid float precision loss.
    pub fn record_profit(&self, chain_id: u64, revenue_wei: U256, gas_cost_wei: U256) {
        let rev_i256 = I256::from_raw(revenue_wei);
        let cost_i256 = I256::from_raw(gas_cost_wei);

        // Net = Revenue - Cost (Can be negative)
        let net = rev_i256.saturating_sub(cost_i256);

        self.net_pnl_wei
            .entry(chain_id)
            .and_modify(|v| *v = v.saturating_add(net))
            .or_insert(net);

        self.total_gas_spent_wei
            .entry(chain_id)
            .and_modify(|v| *v = v.saturating_add(gas_cost_wei))
            .or_insert(gas_cost_wei);
    }

    pub fn record_token_profit(&self, chain_id: u64, token: Address, delta_wei: I256) {
        self.token_profit_wei
            .entry((chain_id, token))
            .and_modify(|v| *v = v.saturating_add(delta_wei))
            .or_insert(delta_wei);
    }

    /// Used by StrategyExecutor for logic checks (e.g. gas boost decisions)
    pub fn get_net_profit_i256(&self, chain_id: u64) -> I256 {
        self.net_pnl_wei
            .get(&chain_id)
            .map(|v| *v)
            .unwrap_or(I256::ZERO)
    }

    /// For Logging/Metrics only (Returns f64 approximate)
    pub fn net_profit_eth(&self, chain_id: u64) -> f64 {
        let wei = self.get_net_profit_i256(chain_id);
        i256_to_eth_f64(wei)
    }

    pub fn net_profit_all(&self) -> Vec<(u64, f64)> {
        self.net_pnl_wei
            .iter()
            .map(|entry| {
                let chain = *entry.key();
                let wei = *entry.value();
                (chain, i256_to_eth_f64(wei))
            })
            .collect()
    }

    pub fn token_profit_all(&self) -> Vec<(u64, Address, f64)> {
        self.token_profit_wei
            .iter()
            .map(|entry| {
                let (chain, token) = *entry.key();
                let wei = *entry.value();
                (chain, token, i256_to_eth_f64(wei))
            })
            .collect()
    }
}

// Helpers for Display only
fn i256_to_eth_f64(val: I256) -> f64 {
    let sign = if val.is_negative() { -1.0 } else { 1.0 };
    // Convert abs value to string then parse to avoid u64 overflow on very large accumulators
    let abs = val.abs().into_raw();
    let num = abs.to_string().parse::<f64>().unwrap_or(0.0);
    sign * (num / 1e18)
}

#[cfg(test)]
mod tests {

    #[tokio::test]
    async fn records_profit_and_net() {
        let dummy_provider = HttpProvider::new_http(Url::parse("http://localhost:8545").unwrap());
        let pm = PortfolioManager::new(dummy_provider, Address::ZERO);

        let revenue = U256::from(1_500_000_000_000_000_000u128); // 1.5 ETH
        let cost = U256::from(400_000_000_000_000_000u128); // 0.4 ETH

        pm.record_profit(1, revenue, cost); // Net +1.1

        let pnl = pm.get_net_profit_i256(1);
        let expected = I256::from_raw(U256::from(1_100_000_000_000_000_000u128));
        assert_eq!(pnl, expected);

        // Float conversion check
        let float_pnl = pm.net_profit_eth(1);
        assert!((float_pnl - 1.1).abs() < 1e-9);
    }
}
//==================================================================================================
// END:   services/strategy/portfolio.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/safety.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


pub struct SafetyGuard {
    consecutive_failures: AtomicUsize,
    last_failure_ts: AtomicUsize,
    max_failures: usize,
    reset_interval_sec: u64,
}

impl SafetyGuard {
    pub fn new() -> Self {
        Self {
            consecutive_failures: AtomicUsize::new(0),
            last_failure_ts: AtomicUsize::new(0),
            max_failures: 5,
            reset_interval_sec: 300,
        }
    }

    pub fn check(&self) -> Result<(), AppError> {
        let failures = self.consecutive_failures.load(Ordering::Relaxed);
        if failures >= self.max_failures {
            let now = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();
            let last = self.last_failure_ts.load(Ordering::Relaxed) as u64;

            if now - last > self.reset_interval_sec {
                self.reset();
            } else {
                return Err(AppError::Strategy(
                    "Circuit Breaker Tripped: Too many recent failures".into(),
                ));
            }
        }
        Ok(())
    }

    pub fn report_success(&self) {
        self.consecutive_failures.store(0, Ordering::Relaxed);
    }

    pub fn report_failure(&self) {
        let count = self.consecutive_failures.fetch_add(1, Ordering::Relaxed);
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        self.last_failure_ts.store(now as usize, Ordering::Relaxed);

        if count + 1 >= self.max_failures {
            tracing::error!("SAFETY GUARD: Circuit Breaker Tripped!");
        }
    }

    fn reset(&self) {
        self.consecutive_failures.store(0, Ordering::Relaxed);
        tracing::info!("Safety Guard: Circuit breaker auto-reset.");
    }
}
//==================================================================================================
// END:   services/strategy/safety.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/simulation.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>


#[derive(Debug, Clone)]
pub struct SimulationOutcome {
    pub success: bool,
    pub gas_used: u64,
    pub return_data: Vec<u8>,
}

#[derive(Clone)]
pub struct Simulator {
    provider: HttpProvider,
}

impl Simulator {
    pub fn new(provider: HttpProvider) -> Self {
        Self { provider }
    }

    pub async fn simulate_transaction(
        &self,
        tx: &Transaction,
    ) -> Result<SimulationOutcome, AppError> {
        let req = tx.clone().into_request();
        self.simulate_request(req, None).await
    }

    pub async fn simulate_request(
        &self,
        req: TransactionRequest,
        state_override: Option<StateOverride>,
    ) -> Result<SimulationOutcome, AppError> {
        if state_override.is_some() {
            let block = SimBlock {
                block_overrides: None,
                state_overrides: state_override.clone(),
                calls: vec![req.clone()],
            };
            let payload = SimulatePayload {
                block_state_calls: vec![block],
                trace_transfers: false,
                validation: false,
                return_full_transactions: false,
            };

            if let Ok(simulated) = self.provider.simulate(&payload).await {
                if let Some(call) = simulated.first().and_then(|b| b.calls.first()) {
                    let success = call.error.is_none() && call.status;

                    if !success {
                        let reason = decode_flashloan_revert(&call.return_data);
                        tracing::warn!("Simulation Revert Reason: {}", reason);
                    }

                    return Ok(SimulationOutcome {
                        success,
                        gas_used: call.gas_used,
                        return_data: call.return_data.to_vec(),
                    });
                }
            }
        }

        let gas_used = match self.provider.estimate_gas(req.clone()).await {
            Ok(g) => g,
            Err(e) => {
                return Ok(SimulationOutcome {
                    success: false,
                    gas_used: 0,
                    return_data: format!("estimate_gas failed: {e}").into_bytes(),
                });
            }
        };

        let call_res = self.provider.call(req).await;

        let (success, return_data) = match call_res {
            Ok(bytes) => (true, bytes.to_vec()),
            Err(_) => (false, Vec::new()),
        };

        Ok(SimulationOutcome {
            success,
            gas_used,
            return_data,
        })
    }

    pub async fn simulate_bundle(
        &self,
        txs: &[Transaction],
        state_override: Option<StateOverride>,
    ) -> Result<Vec<SimulationOutcome>, AppError> {
        let reqs: Vec<TransactionRequest> = txs.iter().cloned().map(|t| t.into_request()).collect();
        self.simulate_bundle_requests(&reqs, state_override).await
    }

    pub async fn simulate_bundle_requests(
        &self,
        txs: &[TransactionRequest],
        state_override: Option<StateOverride>,
    ) -> Result<Vec<SimulationOutcome>, AppError> {
        if txs.is_empty() {
            return Ok(Vec::new());
        }

        let calls = txs.to_vec();
        let block = SimBlock {
            block_overrides: None,
            state_overrides: state_override.clone(),
            calls,
        };
        let payload = SimulatePayload {
            block_state_calls: vec![block],
            trace_transfers: false,
            validation: false,
            return_full_transactions: false,
        };

        match self.provider.simulate(&payload).await {
            Ok(blocks) => {
                let mut out = Vec::new();
                for blk in blocks {
                    for (i, tx) in blk.calls.iter().enumerate() {
                        let success = tx.error.is_none() && tx.status;

                        if !success {
                            let reason = decode_flashloan_revert(&tx.return_data);
                            tracing::warn!("Bundle Tx {} Revert: {}", i, reason);
                        }

                        out.push(SimulationOutcome {
                            success,
                            gas_used: tx.gas_used,
                            return_data: tx.return_data.to_vec(),
                        });
                    }
                }
                return Ok(out);
            }
            Err(_) => {
                let mut out = Vec::new();
                for tx in txs {
                    out.push(
                        self.simulate_request(tx.clone(), state_override.clone())
                            .await?,
                    );
                }
                Ok(out)
            }
        }
    }
}

pub fn decode_flashloan_revert(revert_data: &[u8]) -> String {
    if revert_data.is_empty() {
        return "Reverted with no data (OOG or empty)".to_string();
    }

    // Try decoding against our custom errors
    // Note: SolError trait provides abi_decode for the enum generated by sol!
    if let Ok(decoded) =
        UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::abi_decode(revert_data)
    {
        #[allow(unreachable_patterns)]
        return match decoded {
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::InsufficientFundsForRepayment(e) => {
                format!(
                    "📉 INSOLVENT: Needed {} of token {:?}, but only had {}",
                    e.required, e.token, e.available
                )
            }
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::ExecutionFailed(e) => {
                let inner_msg = String::from_utf8(e.reason.to_vec())
                    .unwrap_or_else(|_| format!("0x{}", hex::encode(&e.reason)));
                format!("💥 STRATEGY FAILED at index {}: {}", e.index, inner_msg)
            }
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::LengthMismatch(_) => "🚫 Array Length Mismatch".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::ZeroAssets(_) => "🚫 Zero Assets requested".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::TokenTransferFailed(_) => "🔒 Token Transfer Failed (USDT?)".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::ApprovalFailed(_) => "🔒 Approval failed (USDT-style)".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::InvalidWETHAddress(_) => "🚫 Invalid WETH address".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::InvalidProfitReceiver(_) => "🚫 Invalid profit receiver".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::BribeFailed(_) => "💰 Bribe payment failed".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::OnlyOwner(_) => "🚫 Caller is not owner".to_string(),
            UnifiedHardenedExecutor::UnifiedHardenedExecutorErrors::OnlyVault(_) => "🚫 Caller is not Balancer Vault".to_string(),
            _ => "Reverted with known custom error".to_string(), // Fallback if Debug is missing
        };
    }

    // Try decoding standard Error(string)
    if let Ok(msg) = Revert::abi_decode(revert_data) {
        return format!("Standard Revert: {}", msg.reason());
    }

    // Unknown binary data
    format!("Unknown Revert: 0x{}", hex::encode(revert_data))
}
//==================================================================================================
// END:   services/strategy/simulation.rs
//==================================================================================================

//==================================================================================================
// BEGIN: services/strategy/strategy.rs
//==================================================================================================
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 ® John Hauger Mitander <john@on1.no>

use crate::common::constants::{
    CHAIN_ARBITRUM, CHAIN_ETHEREUM, CHAIN_OPTIMISM, CHAIN_POLYGON, MIN_PROFIT_THRESHOLD_WEI,
};

#[derive(Debug)]
pub enum StrategyWork {
    Mempool(Transaction),
    MevShareHint(MevShareHint),
}

const VICTIM_FEE_BUMP_BPS: u64 = 11_000;
const TAX_TOLERANCE_BPS: u64 = 500;
const PROBE_GAS_LIMIT: u64 = 220_000;

sol! {
    #[derive(Debug, PartialEq, Eq)]
    #[sol(rpc)]
    contract UniV2Router {
        function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) payable returns (uint256[] memory amounts);
        function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) returns (uint256[] memory amounts);
        function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) returns (uint256[] memory amounts);
        function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);
    }

    #[derive(Debug, PartialEq, Eq)]
    #[sol(rpc)]
    contract UniV3Router {
        struct ExactInputSingleParams {
            address tokenIn;
            address tokenOut;
            uint24 fee;
            address recipient;
            uint256 deadline;
            uint256 amountIn;
            uint256 amountOutMinimum;
            uint160 sqrtPriceLimitX96;
        }
        struct ExactInputParams {
            bytes path;
            address recipient;
            uint256 deadline;
            uint256 amountIn;
            uint256 amountOutMinimum;
        }
        function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
        function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
    }

    #[derive(Debug, PartialEq, Eq)]
    #[sol(rpc)]
    contract UniV3Quoter {
        function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut);
        function quoteExactInput(bytes path, uint256 amountIn) external returns (uint256 amountOut);
    }

    #[derive(Debug, PartialEq, Eq)]
    #[sol(rpc)]
    contract ERC20 {
        function balanceOf(address) external view returns (uint256);
        function allowance(address owner, address spender) external view returns (uint256);
        function approve(address spender, uint256 amount) external returns (bool);
    }
}

use UniV2Router::{
    swapExactETHForTokensCall, swapExactTokensForETHCall, swapExactTokensForTokensCall,
};

#[derive(Default)]
pub struct StrategyStats {
    pub processed: AtomicU64,
    pub submitted: AtomicU64,
    pub skipped: AtomicU64,
    pub failed: AtomicU64,
    pub skip_unknown_router: AtomicU64,
    pub skip_decode_failed: AtomicU64,
    pub skip_missing_wrapped: AtomicU64,
    pub skip_gas_cap: AtomicU64,
    pub skip_sim_failed: AtomicU64,
    pub skip_profit_guard: AtomicU64,
    pub skip_unsupported_router: AtomicU64,
    pub skip_token_call: AtomicU64,
    pub skip_toxic_token: AtomicU64,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum RouterKind {
    V2Like,
    V3Like,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum SwapDirection {
    BuyWithEth,
    SellForEth,
    Other,
}

pub struct StrategyExecutor {
    tx_rx: Mutex<UnboundedReceiver<StrategyWork>>,
    mut_block_rx: Mutex<Receiver<Header>>,
    safety_guard: Arc<SafetyGuard>,
    bundle_sender: SharedBundleSender,
    db: Database,
    portfolio: Arc<PortfolioManager>,
    gas_oracle: GasOracle,
    price_feed: PriceFeed,
    chain_id: u64,
    stats: Arc<StrategyStats>,
    max_gas_price_gwei: u64,
    simulator: Simulator,
    token_manager: Arc<TokenManager>,
    signer: PrivateKeySigner,
    nonce_manager: NonceManager,
    slippage_bps: u64,
    http_provider: HttpProvider,
    dry_run: bool,
    router_allowlist: HashSet<Address>,
    wrapped_native: Address,
    inventory_tokens: DashSet<Address>,
    last_rebalance: Mutex<Instant>,
    toxic_tokens: DashSet<Address>,
    executor: Option<Address>,
    executor_bribe_bps: u64,
    executor_bribe_recipient: Option<Address>,
    flashloan_enabled: bool,
}

#[derive(Clone, Debug)]
struct ObservedSwap {
    router: Address,
    path: Vec<Address>,
    v3_fees: Vec<u32>,
    v3_path: Option<Vec<u8>>,
    amount_in: U256,
    min_out: U256,
    recipient: Address,
    router_kind: RouterKind,
}

#[derive(Clone, Debug)]
struct ParsedV3Path {
    tokens: Vec<Address>,
    fees: Vec<u32>,
}

struct BackrunTx {
    raw: Vec<u8>,
    hash: B256,
    to: Address,
    value: U256,
    request: TransactionRequest,
    expected_out: U256,
    uses_flashloan: bool,
    router_kind: RouterKind,
}

struct FrontRunTx {
    raw: Vec<u8>,
    hash: B256,
    to: Address,
    value: U256,
    request: TransactionRequest,
    expected_tokens: U256,
}

struct ApproveTx {
    raw: Vec<u8>,
    request: TransactionRequest,
}

impl StrategyExecutor {
    fn price_ratio_ppm(amount_out: U256, amount_in: U256) -> U256 {
        if amount_in.is_zero() {
            return U256::ZERO;
        }
        amount_out.saturating_mul(U256::from(1_000_000u64)) / amount_in
    }

    fn log_skip(&self, reason: &str, detail: &str) {
        if self.dry_run {
            tracing::info!(target: "strategy_skip", %reason, %detail, "Dry-run skip");
        } else {
            tracing::debug!(target: "strategy_skip", %reason, %detail);
        }

        match reason {
            "unknown_router" => {
                self.stats
                    .skip_unknown_router
                    .fetch_add(1, Ordering::Relaxed);
            }
            "decode_failed" => {
                self.stats
                    .skip_decode_failed
                    .fetch_add(1, Ordering::Relaxed);
            }
            "zero_amount_or_no_wrapped_native" => {
                self.stats
                    .skip_missing_wrapped
                    .fetch_add(1, Ordering::Relaxed);
            }
            "gas_price_cap" => {
                self.stats.skip_gas_cap.fetch_add(1, Ordering::Relaxed);
            }
            "simulation_failed" => {
                self.stats.skip_sim_failed.fetch_add(1, Ordering::Relaxed);
            }
            "profit_or_gas_guard" => {
                self.stats.skip_profit_guard.fetch_add(1, Ordering::Relaxed);
            }
            "unsupported_router_type" => {
                self.stats
                    .skip_unsupported_router
                    .fetch_add(1, Ordering::Relaxed);
            }
            "token_call" => {
                self.stats.skip_token_call.fetch_add(1, Ordering::Relaxed);
            }
            "toxic_token" => {
                self.stats.skip_toxic_token.fetch_add(1, Ordering::Relaxed);
            }
            _ => {}
        }
    }

    fn amount_to_display(&self, amount: U256, token: Address) -> f64 {
        let decimals = self
            .token_manager
            .decimals(self.chain_id, token)
            .unwrap_or(18);
        units_to_float(amount, decimals)
    }

    pub fn new(
        tx_rx: UnboundedReceiver<StrategyWork>,
        block_rx: Receiver<Header>,
        safety_guard: Arc<SafetyGuard>,
        bundle_sender: SharedBundleSender,
        db: Database,
        portfolio: Arc<PortfolioManager>,
        gas_oracle: GasOracle,
        price_feed: PriceFeed,
        chain_id: u64,
        max_gas_price_gwei: u64,
        simulator: Simulator,
        token_manager: Arc<TokenManager>,
        stats: Arc<StrategyStats>,
        signer: PrivateKeySigner,
        nonce_manager: NonceManager,
        slippage_bps: u64,
        http_provider: HttpProvider,
        dry_run: bool,
        router_allowlist: HashSet<Address>,
        wrapped_native: Address,
        executor: Option<Address>,
        executor_bribe_bps: u64,
        executor_bribe_recipient: Option<Address>,
        flashloan_enabled: bool,
    ) -> Self {
        Self {
            tx_rx: Mutex::new(tx_rx),
            mut_block_rx: Mutex::new(block_rx),
            safety_guard,
            bundle_sender,
            db,
            portfolio,
            gas_oracle,
            price_feed,
            chain_id,
            stats,
            max_gas_price_gwei,
            simulator,
            token_manager,
            signer,
            nonce_manager,
            slippage_bps,
            http_provider,
            dry_run,
            router_allowlist,
            wrapped_native,
            inventory_tokens: DashSet::new(),
            last_rebalance: Mutex::new(Instant::now()),
            toxic_tokens: DashSet::new(),
            executor,
            executor_bribe_bps,
            executor_bribe_recipient,
            flashloan_enabled,
        }
    }

    pub async fn run(self) -> Result<(), AppError> {
        tracing::info!("StrategyExecutor: waiting for pending transactions");

        let executor = Arc::new(self);

        // Spawn a lightweight block watcher so work processing never waits on block stream.
        let block_exec = executor.clone();
        tokio::spawn(async move {
            block_exec.block_watcher().await;
        });

        loop {
            let work_opt = {
                let mut rx = executor.tx_rx.lock().await;
                rx.recv().await
            };

            match work_opt {
                Some(work) => {
                    let exec = executor.clone();
                    tokio::spawn(async move {
                        exec.process_work(work).await;
                    });
                }
                None => break,
            }
        }

        Ok(())
    }

    async fn block_watcher(self: Arc<Self>) {
        loop {
            let msg = {
                let mut rx = self.mut_block_rx.lock().await;
                rx.recv().await
            };

            match msg {
                Ok(header) => {
                    tracing::debug!("StrategyExecutor: observed new block {:?}", header.hash);
                    let _ = self.maybe_rebalance_inventory().await;
                }
                Err(tokio::sync::broadcast::error::RecvError::Closed) => break,
                Err(tokio::sync::broadcast::error::RecvError::Lagged(_)) => continue,
            }
        }
    }

    async fn process_work(self: Arc<Self>, work: StrategyWork) {
        if let Err(e) = self.handle_work(work).await {
            tracing::error!(target: "strategy", error=%e, "Strategy task failed");
        }
    }

    async fn populate_access_list(&self, req: &mut TransactionRequest) {
        match self.http_provider.create_access_list(&req.clone()).await {
            Ok(res) => {
                let list = res.ensure_ok().map(|r| r.access_list).unwrap_or_default();
                if !list.0.is_empty() {
                    req.access_list = Some(list);
                }
            }
            Err(e) => {
                tracing::debug!(
                    target: "access_list",
                    error=%e,
                    "eth_createAccessList failed; continuing without access list"
                );
            }
        }
    }

    async fn apply_access_list(
        &self,
        req: &mut TransactionRequest,
        fallback: AccessList,
    ) -> AccessList {
        self.populate_access_list(req).await;
        req.access_list.clone().unwrap_or(fallback)
    }

    async fn sign_with_access_list(
        &self,
        mut request: TransactionRequest,
        fallback: AccessList,
    ) -> Result<(Vec<u8>, TransactionRequest, B256), AppError> {
        let access_list = self.apply_access_list(&mut request, fallback).await;

        let to = request
            .to
            .ok_or_else(|| AppError::Strategy("Missing `to` in tx request".into()))?;
        let gas = request
            .gas
            .ok_or_else(|| AppError::Strategy("Missing `gas` in tx request".into()))?;
        let value = request.value.unwrap_or_default();
        let max_fee_per_gas = request.max_fee_per_gas.ok_or_else(|| {
            AppError::Strategy("Missing max_fee_per_gas in tx request".into())
        })?;
        let max_priority_fee_per_gas = request.max_priority_fee_per_gas.ok_or_else(|| {
            AppError::Strategy("Missing max_priority_fee_per_gas in tx request".into())
        })?;
        let nonce = request
            .nonce
            .ok_or_else(|| AppError::Strategy("Missing nonce in tx request".into()))?;
        let chain_id = request
            .chain_id
            .unwrap_or(self.chain_id);
        let input_bytes = request
            .input
            .clone()
            .into_input()
            .map(Bytes::from)
            .unwrap_or_default();

        let mut tx = TxEip1559 {
            chain_id,
            nonce,
            max_priority_fee_per_gas,
            max_fee_per_gas,
            gas_limit: gas,
            to,
            value,
            access_list,
            input: input_bytes,
        };

        let sig = TxSignerSync::sign_transaction_sync(&self.signer, &mut tx)
            .map_err(|e| AppError::Strategy(format!("Sign tx failed: {}", e)))?;
        let signed: TxEnvelope = tx.into_signed(sig).into();
        let raw = signed.encoded_2718();
        Ok((raw, request, *signed.tx_hash()))
    }

    async fn sign_swap_request(
        &self,
        to: Address,
        gas_limit: u64,
        value: U256,
        max_fee_per_gas: u128,
        max_priority_fee_per_gas: u128,
        nonce: u64,
        calldata: Vec<u8>,
        access_list: AccessList,
    ) -> Result<(Vec<u8>, TransactionRequest, B256), AppError> {
        let request = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(to)),
            max_fee_per_gas: Some(max_fee_per_gas),
            max_priority_fee_per_gas: Some(max_priority_fee_per_gas),
            gas: Some(gas_limit),
            value: Some(value),
            input: TransactionInput::new(calldata.into()),
            nonce: Some(nonce),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };

        self.sign_with_access_list(request, access_list).await
    }

    async fn handle_work(&self, work: StrategyWork) -> Result<(), AppError> {
        self.safety_guard.check()?;

        let outcome = match work {
            StrategyWork::Mempool(tx) => {
                let from = tx.from();
                let res = self.evaluate_mempool_tx(&tx).await;
                (res, Some(from), Some(tx.tx_hash()))
            }
            StrategyWork::MevShareHint(hint) => {
                let res = self.evaluate_mev_share_hint(&hint).await;
                (res, hint.from, Some(hint.tx_hash))
            }
        };

        match outcome {
            (Ok(Some(tx_hash)), from, _) => {
                tracing::info!(
                    target: "strategy",
                    from = ?from,
                    tx_hash = %tx_hash,
                    "Bundle submitted"
                );
                self.safety_guard.report_success();
                self.stats.submitted.fetch_add(1, Ordering::Relaxed);
            }
            (Ok(None), from, tx_hash) => {
                tracing::debug!(
                    target: "strategy",
                    from=?from,
                    tx_hash=?tx_hash,
                    "Skipped item"
                );
                self.stats.skipped.fetch_add(1, Ordering::Relaxed);
            }
            (Err(e), _, _) => {
                self.safety_guard.report_failure();
                self.stats.failed.fetch_add(1, Ordering::Relaxed);
                tracing::error!(target: "strategy", error=%e, "Strategy failed");
            }
        };

        let processed = self.stats.processed.fetch_add(1, Ordering::Relaxed) + 1;
        if processed % 50 == 0 {
            tracing::info!(
                target: "strategy_summary",
                processed,
                submitted = self.stats.submitted.load(Ordering::Relaxed),
                skipped = self.stats.skipped.load(Ordering::Relaxed),
                failed = self.stats.failed.load(Ordering::Relaxed),
                skip_unknown_router = self.stats.skip_unknown_router.load(Ordering::Relaxed),
                skip_decode = self.stats.skip_decode_failed.load(Ordering::Relaxed),
                skip_missing_wrapped = self.stats.skip_missing_wrapped.load(Ordering::Relaxed),
                skip_gas_cap = self.stats.skip_gas_cap.load(Ordering::Relaxed),
                skip_sim_failed = self.stats.skip_sim_failed.load(Ordering::Relaxed),
                skip_profit_guard = self.stats.skip_profit_guard.load(Ordering::Relaxed),
                skip_unsupported_router = self.stats.skip_unsupported_router.load(Ordering::Relaxed),
                skip_token_call = self.stats.skip_token_call.load(Ordering::Relaxed),
                "Strategy loop summary"
            );
        }

        Ok(())
    }

    async fn evaluate_mempool_tx(&self, tx: &Transaction) -> Result<Option<String>, AppError> {
        let to_addr = match tx.kind() {
            TxKind::Call(addr) => addr,
            TxKind::Create => return Ok(None),
        };

        if !self.router_allowlist.contains(&to_addr) {
            if Self::is_common_token_call(tx.input()) {
                self.log_skip("token_call", "erc20 transfer/approve");
                return Ok(None);
            }
            self.log_skip("unknown_router", &format!("to={to_addr:#x}"));
            return Ok(None);
        }

        let Some(observed_swap) = Self::decode_swap(tx) else {
            self.log_skip("decode_failed", "unable to decode swap input");
            return Ok(None);
        };
        if observed_swap.amount_in.is_zero() || !observed_swap.path.contains(&self.wrapped_native) {
            self.log_skip(
                "zero_amount_or_no_wrapped_native",
                "path missing wrapped native or zero amount",
            );
            return Ok(None);
        }
        let direction = Self::direction(&observed_swap, self.wrapped_native);
        let target_token = match Self::target_token(&observed_swap.path, self.wrapped_native) {
            Some(t) => t,
            None => {
                self.log_skip("decode_failed", "no target token");
                return Ok(None);
            }
        };
        if self.toxic_tokens.contains(&target_token) {
            self.log_skip("toxic_token", &format!("token={:#x}", target_token));
            return Ok(None);
        }
        self.inventory_tokens.insert(target_token);
        let tx_value = tx.value();

        let mut gas_fees: GasFees = self.gas_oracle.estimate_eip1559_fees().await?;
        self.boost_fees(&mut gas_fees, None, None);
        let gas_cap_wei = U256::from(self.max_gas_price_gwei) * U256::from(1_000_000_000u64);
        if U256::from(gas_fees.max_fee_per_gas) > gas_cap_wei {
            self.log_skip(
                "gas_price_cap",
                &format!(
                    "max_fee_per_gas={} cap_gwei={}",
                    gas_fees.max_fee_per_gas, self.max_gas_price_gwei
                ),
            );
            return Ok(None);
        }

        let real_balance = self.portfolio.update_eth_balance(self.chain_id).await?;
        let (wallet_chain_balance, _) = if self.dry_run {
            let gas_headroom = U256::from(tx.gas_limit()) * U256::from(gas_fees.max_fee_per_gas);
            let value_headroom = tx.value().saturating_mul(U256::from(2u64));
            let mock = gas_headroom
                .saturating_add(value_headroom)
                .max(U256::from(500_000_000_000_000_000u128)); // floor 0.5 ETH
            (mock, true)
        } else {
            (real_balance, false)
        };
        let base_gas_budget = U256::from(tx.gas_limit()) * U256::from(gas_fees.max_fee_per_gas);
        if !self.dry_run {
            self.portfolio
                .ensure_funding(self.chain_id, base_gas_budget)?;
        }

        let mut attack_value_eth = U256::ZERO;
        let mut bundle_requests: Vec<TransactionRequest> = Vec::new();
        let mut raw_bundle: Vec<Vec<u8>> = Vec::new();
        let executor_tx: Option<(Vec<u8>, TransactionRequest, B256)>;
        let executor_hash: Option<B256>;

        let mut front_run: Option<FrontRunTx> = None;
        let mut approval: Option<ApproveTx> = None;
        if direction == SwapDirection::BuyWithEth {
            let nonce_front = self.nonce_manager.get_next_nonce().await?;
            match self
                .build_front_run_tx(
                    &observed_swap,
                    gas_fees.max_fee_per_gas,
                    gas_fees.max_priority_fee_per_gas,
                    wallet_chain_balance,
                    tx.gas_limit(),
                    nonce_front,
                )
                .await
            {
                Ok(Some(f)) => {
                    attack_value_eth = f.value;
                    bundle_requests.push(f.request.clone());
                    raw_bundle.push(f.raw.clone());
                    front_run = Some(f);
                }
                Ok(None) => {}
                Err(e) => {
                    self.log_skip("front_run_build_failed", &e.to_string());
                    return Ok(None);
                }
            }
        }

        if let Some(f) = &front_run {
            if self
                .needs_approval(target_token, observed_swap.router, f.expected_tokens)
                .await?
            {
                let needed_nonce = self.nonce_manager.get_next_nonce().await?;
                approval = Some(
                    self.build_approval_tx(
                        target_token,
                        observed_swap.router,
                        gas_fees.max_fee_per_gas,
                        gas_fees.max_priority_fee_per_gas,
                        needed_nonce,
                    )
                    .await?,
                );
            }
        }

        let use_flashloan =
            self.should_use_flashloan(observed_swap.amount_in, wallet_chain_balance, &gas_fees)
                && front_run.is_none();

        let sim_balance = U256::from_str("10000000000000000000000")
            .unwrap_or_else(|_| U256::from(u128::MAX));
        let trade_balance = if use_flashloan {
            sim_balance
        } else {
            wallet_chain_balance
        };

        let nonce_backrun = self.nonce_manager.get_next_nonce().await?;

        let backrun = match self
            .build_backrun_tx(
                &observed_swap,
                gas_fees.max_fee_per_gas,
                gas_fees.max_priority_fee_per_gas,
                trade_balance,
                tx.gas_limit(),
                front_run.as_ref().map(|f| f.expected_tokens),
                use_flashloan,
                nonce_backrun,
            )
            .await
        {
            Ok(b) => b,
            Err(e) => {
                self.log_skip("backrun_build_failed", &e.to_string());
                return Ok(None);
            }
        };
        let backrun_raw = backrun.raw.clone();
        let sim_nonce = front_run
            .as_ref()
            .and_then(|f| f.request.nonce)
            .or_else(|| backrun.request.nonce)
            .unwrap_or_default();

        let overrides = StateOverridesBuilder::default()
            .with_balance(self.signer.address(), sim_balance)
            .with_nonce(self.signer.address(), sim_nonce)
            .build();

        // Build optional executor wrapper for approval + backrun legs.
        executor_tx = self
            .build_executor_wrapper(
                approval.as_ref(),
                &backrun,
                &gas_fees,
                tx.gas_limit(),
                nonce_backrun,
            )
            .await?;
        executor_hash = executor_tx.as_ref().map(|(_, _, h)| *h);

        if let Some(f) = &front_run {
            bundle_requests.push(f.request.clone());
            raw_bundle.push(f.raw.clone());
        }
        bundle_requests.push(tx.clone().into_request());
        raw_bundle.push(tx.inner.encoded_2718());

        if let Some((raw, req, _)) = &executor_tx {
            bundle_requests.push(req.clone());
            raw_bundle.push(raw.clone());
        } else {
            if let Some(app) = &approval {
                bundle_requests.push(app.request.clone());
                raw_bundle.push(app.raw.clone());
            }
            bundle_requests.push(backrun.request.clone());
            raw_bundle.push(backrun_raw.clone());
        }
        let mut bundle_reqs_for_sim = bundle_requests.clone();
        for req in bundle_reqs_for_sim.iter_mut() {
            self.populate_access_list(req).await;
        }
        let overrides_for_sim = overrides.clone();
        let bundle_sims = retry_async(
            move |_| {
                let simulator = self.simulator.clone();
                let overrides = overrides_for_sim.clone();
                let reqs = bundle_reqs_for_sim.clone();
                async move {
                    simulator
                        .simulate_bundle_requests(&reqs, Some(overrides))
                        .await
                }
            },
            2,
            Duration::from_millis(100),
        )
        .await?;
        if bundle_sims.iter().any(|o| !o.success) {
            self.log_skip("simulation_failed", "bundle sim returned failure");
            return Ok(None);
        }

        let mut gas_used_total = 0u64;
        for sim in &bundle_sims {
            gas_used_total = gas_used_total.saturating_add(sim.gas_used);
        }
        let bundle_gas_limit = gas_used_total.max(tx.gas_limit());
        let gas_cost_wei = U256::from(bundle_gas_limit) * U256::from(gas_fees.max_fee_per_gas);

        if !self.dry_run {
            let spend = if backrun.uses_flashloan {
                U256::ZERO
            } else {
                backrun.value.saturating_add(attack_value_eth)
            };
            self.portfolio
                .ensure_funding(self.chain_id, spend + gas_cost_wei)?;
        }

        let total_eth_in = backrun.value.saturating_add(attack_value_eth);
        let gross_profit_wei = backrun.expected_out.saturating_sub(total_eth_in);

        // --- PROFIT CHECK (U256 Safe) ---
        if gas_cost_wei > gross_profit_wei {
            self.log_skip("profit_or_gas_guard", "Gas > Gross Profit");
            return Ok(None);
        }

        let net_profit_wei = gross_profit_wei.saturating_sub(gas_cost_wei);
        let profit_floor = StrategyExecutor::dynamic_profit_floor(wallet_chain_balance);

        if net_profit_wei < profit_floor {
            self.log_skip(
                "profit_or_gas_guard",
                &format!("Net {} < Floor {}", net_profit_wei, profit_floor),
            );
            return Ok(None);
        }

        if !self.gas_ratio_ok(gas_cost_wei, gross_profit_wei, wallet_chain_balance) {
            self.log_skip("profit_or_gas_guard", "Bad Risk/Reward");
            return Ok(None);
        }

        // --- Logging/Persistence (Safe to use f64 here for display) ---
        let eth_quote = self.price_feed.get_price("ETHUSD").await?;
        let profit_eth_f64 = self.amount_to_display(gross_profit_wei, self.wrapped_native);
        let gas_cost_eth_f64 = self.amount_to_display(gas_cost_wei, self.wrapped_native);
        let net_profit_eth_f64 = self.amount_to_display(net_profit_wei, self.wrapped_native);

        tracing::info!(
            target: "strategy",
            gas_limit = bundle_gas_limit,
            max_fee_per_gas = gas_fees.max_fee_per_gas,
            gas_cost_wei = %gas_cost_wei,
            net_profit_wei = %net_profit_wei,
            net_profit_eth = net_profit_eth_f64,
            wallet_eth = self.amount_to_display(wallet_chain_balance, self.wrapped_native),
            price_source = %eth_quote.source,
            price = eth_quote.price,
            victim_min_out = ?observed_swap.min_out,
            victim_recipient = ?observed_swap.recipient,
            path_len = observed_swap.path.len(),
            path = ?observed_swap.path,
            router = ?observed_swap.router,
            used_mock_balance = self.dry_run,
            sandwich = front_run.is_some(),
            "Strategy evaluation"
        );

        let tx_hash = tx.tx_hash();

        if self.dry_run {
            tracing::info!(
                target: "strategy_dry_run",
                tx_hash = %format!("{:#x}", tx_hash),
                net_profit_eth = net_profit_eth_f64,
                gross_profit_eth = profit_eth_f64,
                gas_cost_eth = gas_cost_eth_f64,
                front_run_value_eth = self.amount_to_display(attack_value_eth, self.wrapped_native),
                sandwich = front_run.is_some(),
                "Dry-run only: simulated profitable bundle (not sent)"
            );
            return Ok(Some(format!("{tx_hash:#x}")));
        }

        let _ = self
            .db
            .update_status(&format!("{:#x}", backrun.hash), None, Some(false))
            .await;

        if let Err(e) = self
            .bundle_sender
            .send_bundle(&raw_bundle, self.chain_id)
            .await
        {
            self.emergency_exit_inventory("bundle send failed").await;
            return Err(e);
        }

        let to_addr = match tx.kind() {
            TxKind::Call(addr) => Some(addr),
            TxKind::Create => None,
        };

        self.db
            .save_transaction(
                &format!("{tx_hash:#x}"),
                self.chain_id,
                &format!("{:#x}", tx.from()),
                to_addr.as_ref().map(|a| format!("{:#x}", a)).as_deref(),
                tx_value.to_string().as_str(),
                Some("strategy_v1"),
            )
            .await?;
        let recorded_hash = executor_hash.unwrap_or(backrun.hash);
        let recorded_to = executor_tx
            .as_ref()
            .and_then(|(_, req, _)| req.to)
            .or_else(|| Some(TxKind::Call(backrun.to)));
        let recorded_value = executor_tx
            .as_ref()
            .and_then(|(_, req, _)| req.value)
            .unwrap_or(backrun.value);
        self.db
            .save_transaction(
                &format!("{:#x}", recorded_hash),
                self.chain_id,
                &format!("{:#x}", self.signer.address()),
                recorded_to
                    .as_ref()
                    .and_then(|k| match k {
                        TxKind::Call(a) => Some(format!("{:#x}", a)),
                        _ => None,
                    })
                    .as_deref(),
                recorded_value.to_string().as_str(),
                Some("strategy_backrun"),
            )
            .await?;
        if let Some(f) = &front_run {
            self.db
                .save_transaction(
                    &format!("{:#x}", f.hash),
                    self.chain_id,
                    &format!("{:#x}", self.signer.address()),
                    Some(format!("{:#x}", f.to)).as_deref(),
                    f.value.to_string().as_str(),
                    Some("strategy_front_run"),
                )
                .await?;
        }

        self.db
            .save_profit_record(
                &format!("{tx_hash:#x}"),
                self.chain_id,
                "strategy_v1",
                profit_eth_f64,
                gas_cost_eth_f64,
                net_profit_eth_f64,
            )
            .await?;

        self.portfolio
            .record_profit(self.chain_id, gross_profit_wei, gas_cost_wei);

        let _ = self
            .db
            .save_market_price(self.chain_id, "ETHUSD", eth_quote.price, &eth_quote.source)
            .await;

        let receipt_target = executor_hash.unwrap_or(backrun.hash);
        if !self.await_receipt(&receipt_target).await? {
            self.emergency_exit_inventory("bundle receipt missing/failed").await;
        }

        Ok(Some(format!("{tx_hash:#x}")))
    }

    async fn evaluate_mev_share_hint(
        &self,
        hint: &MevShareHint,
    ) -> Result<Option<String>, AppError> {
        if !self.router_allowlist.contains(&hint.router) {
            self.log_skip("unknown_router", &format!("to={:#x}", hint.router));
            return Ok(None);
        }

        let Some(observed_swap) = Self::decode_swap_input(hint.router, &hint.call_data, hint.value)
        else {
            self.log_skip("decode_failed", "unable to decode swap input");
            return Ok(None);
        };

        if observed_swap.router_kind == RouterKind::V3Like {
            self.log_skip(
                "unsupported_router_type",
                "uniswap_v3 not yet implemented for backrun",
            );
            return Ok(None);
        }

        if observed_swap.amount_in.is_zero() || !observed_swap.path.contains(&self.wrapped_native) {
            self.log_skip(
                "zero_amount_or_no_wrapped_native",
                "path missing wrapped native or zero amount",
            );
            return Ok(None);
        }

        let direction = Self::direction(&observed_swap, self.wrapped_native);
        let target_token = match Self::target_token(&observed_swap.path, self.wrapped_native) {
            Some(t) => t,
            None => {
                self.log_skip("decode_failed", "no target token");
                return Ok(None);
            }
        };
        if self.toxic_tokens.contains(&target_token) {
            self.log_skip("toxic_token", &format!("token={:#x}", target_token));
            return Ok(None);
        }
        self.inventory_tokens.insert(target_token);
        let gas_limit_hint = hint.gas_limit.unwrap_or(220_000);

        let mut gas_fees: GasFees = self.gas_oracle.estimate_eip1559_fees().await?;
        self.boost_fees(
            &mut gas_fees,
            hint.max_fee_per_gas,
            hint.max_priority_fee_per_gas,
        );
        let gas_cap_wei = U256::from(self.max_gas_price_gwei) * U256::from(1_000_000_000u64);
        if U256::from(gas_fees.max_fee_per_gas) > gas_cap_wei {
            self.log_skip(
                "gas_price_cap",
                &format!(
                    "max_fee_per_gas={} cap_gwei={}",
                    gas_fees.max_fee_per_gas, self.max_gas_price_gwei
                ),
            );
            return Ok(None);
        }

        let real_balance = self.portfolio.update_eth_balance(self.chain_id).await?;
        let (wallet_chain_balance, _) = if self.dry_run {
            let gas_headroom = U256::from(gas_limit_hint) * U256::from(gas_fees.max_fee_per_gas);
            let value_headroom = hint.value.saturating_mul(U256::from(2u64));
            let mock = gas_headroom
                .saturating_add(value_headroom)
                .max(U256::from(500_000_000_000_000_000u128)); // floor 0.5 ETH
            (mock, true)
        } else {
            (real_balance, false)
        };
        let base_gas_budget = U256::from(gas_limit_hint) * U256::from(gas_fees.max_fee_per_gas);
        if !self.dry_run {
            self.portfolio
                .ensure_funding(self.chain_id, base_gas_budget)?;
        }

        let mut attack_value_eth = U256::ZERO;
        let mut bundle_requests: Vec<TransactionRequest> = Vec::new();
        let mut bundle_body: Vec<BundleItem> = Vec::new();
        let mut executor_tx_raw: Option<Vec<u8>> = None;
        let mut executor_request: Option<TransactionRequest> = None;
        let mut executor_hash: Option<B256> = None;

        let mut front_run: Option<FrontRunTx> = None;
        let mut approval: Option<ApproveTx> = None;
        if direction == SwapDirection::BuyWithEth {
            let nonce_front = self.nonce_manager.get_next_nonce().await?;
            match self
                .build_front_run_tx(
                    &observed_swap,
                    gas_fees.max_fee_per_gas,
                    gas_fees.max_priority_fee_per_gas,
                    wallet_chain_balance,
                    gas_limit_hint,
                    nonce_front,
                )
                .await
            {
                Ok(Some(f)) => {
                    attack_value_eth = f.value;
                    bundle_requests.push(f.request.clone());
                    front_run = Some(f);
                }
                Ok(None) => {}
                Err(e) => {
                    self.log_skip("front_run_build_failed", &e.to_string());
                    return Ok(None);
                }
            }
        }

        if let Some(f) = &front_run {
            if self
                .needs_approval(target_token, observed_swap.router, f.expected_tokens)
                .await?
            {
                let needed_nonce = self.nonce_manager.get_next_nonce().await?;
                approval = Some(
                    self.build_approval_tx(
                        target_token,
                        observed_swap.router,
                        gas_fees.max_fee_per_gas,
                        gas_fees.max_priority_fee_per_gas,
                        needed_nonce,
                    )
                    .await?,
                );
            }
        }

        let nonce_backrun = self.nonce_manager.get_next_nonce().await?;
        let use_flashloan =
            self.should_use_flashloan(observed_swap.amount_in, wallet_chain_balance, &gas_fees)
                && front_run.is_none();
        let sim_balance = U256::from_str("10000000000000000000000")
            .unwrap_or_else(|_| U256::from(u128::MAX));
        let trade_balance = if use_flashloan {
            sim_balance
        } else {
            wallet_chain_balance
        };
        let backrun = match self
            .build_backrun_tx(
                &observed_swap,
                gas_fees.max_fee_per_gas,
                gas_fees.max_priority_fee_per_gas,
                trade_balance,
                gas_limit_hint,
                front_run.as_ref().map(|f| f.expected_tokens),
                use_flashloan,
                nonce_backrun,
            )
            .await
        {
            Ok(b) => b,
            Err(e) => {
                self.log_skip("backrun_build_failed", &e.to_string());
                return Ok(None);
            }
        };
        let backrun_raw = backrun.raw.clone();
        let sim_nonce = front_run
            .as_ref()
            .and_then(|f| f.request.nonce)
            .or_else(|| backrun.request.nonce)
            .unwrap_or_default();

        let overrides = StateOverridesBuilder::default()
            .with_balance(self.signer.address(), sim_balance)
            .with_nonce(self.signer.address(), sim_nonce)
            .build();

        let max_fee_hint = hint.max_fee_per_gas.unwrap_or(gas_fees.max_fee_per_gas);
        let max_prio_hint = hint
            .max_priority_fee_per_gas
            .unwrap_or(gas_fees.max_priority_fee_per_gas);
        let victim_request = TransactionRequest {
            from: hint.from,
            to: Some(TxKind::Call(hint.router)),
            max_fee_per_gas: Some(max_fee_hint),
            max_priority_fee_per_gas: Some(max_prio_hint),
            gas: Some(gas_limit_hint),
            value: Some(hint.value),
            input: TransactionInput::new(hint.call_data.clone().into()),
            nonce: None,
            chain_id: Some(self.chain_id),
            ..Default::default()
        };
        if let Some(app) = &approval {
            bundle_requests.push(app.request.clone());
        }
        bundle_requests.push(victim_request);
        bundle_requests.push(backrun.request.clone());

        // If we can avoid a front-run, wrap our legs in the on-chain executor for atomicity.
        if self.executor.is_some() && front_run.is_none() {
            if let Some(exec_addr) = self.executor {
                let mut targets = Vec::new();
                let mut payloads = Vec::new();
                let mut values = Vec::new();

                if let Some(app) = &approval {
                    if let Some(TxKind::Call(addr)) = app.request.to {
                        targets.push(addr);
                        let bytes = app.request.input.clone().into_input().unwrap_or_default();
                        payloads.push(bytes);
                        values.push(U256::ZERO);
                    }
                }
                if let Some(TxKind::Call(addr)) = backrun.request.to {
                    targets.push(addr);
                    let bytes = backrun
                        .request
                        .input
                        .clone()
                        .into_input()
                        .unwrap_or_default();
                    payloads.push(bytes);
                    values.push(backrun.value);
                }

                if !targets.is_empty() {
                    let total_value = values
                        .iter()
                        .copied()
                        .fold(U256::ZERO, |acc, v| acc.saturating_add(v));
                    let exec_call = UnifiedHardenedExecutor::executeBundleCall {
                        targets,
                        payloads,
                        values,
                        bribeRecipient: Address::ZERO,
                        bribeAmount: U256::ZERO,
                    };
                    let calldata = exec_call.abi_encode();
                    let gas_limit = backrun
                        .request
                        .gas
                        .unwrap_or(gas_limit_hint)
                        .saturating_add(approval.as_ref().and_then(|a| a.request.gas).unwrap_or(0))
                        .saturating_add(80_000);

                    let (raw, request, hash) = self
                        .sign_swap_request(
                            exec_addr,
                            gas_limit,
                            total_value,
                            gas_fees.max_fee_per_gas,
                            gas_fees.max_priority_fee_per_gas,
                            nonce_backrun,
                            calldata,
                            AccessList::default(),
                        )
                        .await?;
                    executor_hash = Some(hash);
                    executor_tx_raw = Some(raw);
                    executor_request = Some(request);
                }
            }
        }

        // Build bundle body in order: victim hash, then our legs (either executor call or raw txs).
        bundle_body.push(BundleItem::Hash {
            hash: format!("{:#x}", hint.tx_hash),
        });
        if let Some(raw) = executor_tx_raw.clone() {
            bundle_body.push(BundleItem::Tx {
                tx: format!("0x{}", hex::encode(&raw)),
                can_revert: false,
            });
        } else {
            if let Some(f) = &front_run {
                bundle_body.push(BundleItem::Tx {
                    tx: format!("0x{}", hex::encode(&f.raw)),
                    can_revert: false,
                });
            }
            if let Some(app) = &approval {
                bundle_body.push(BundleItem::Tx {
                    tx: format!("0x{}", hex::encode(&app.raw)),
                    can_revert: false,
                });
            }
            bundle_body.push(BundleItem::Tx {
                tx: format!("0x{}", hex::encode(&backrun_raw)),
                can_revert: false,
            });
        }

        let exec_req_for_sim = executor_request.clone();
        let mut bundle_reqs_for_sim = bundle_requests.clone();
        for req in bundle_reqs_for_sim.iter_mut() {
            self.populate_access_list(req).await;
        }
        let overrides_for_sim = overrides.clone();
        let bundle_sims = retry_async(
            move |_| {
                let simulator = self.simulator.clone();
                let reqs = if let Some(r) = exec_req_for_sim.clone() {
                    vec![r]
                } else {
                    bundle_reqs_for_sim.clone()
                };
                let overrides = overrides_for_sim.clone();
                async move {
                    simulator
                        .simulate_bundle_requests(&reqs, Some(overrides))
                        .await
                }
            },
            2,
            Duration::from_millis(100),
        )
        .await?;
        if bundle_sims.iter().any(|o| !o.success) {
            self.log_skip("simulation_failed", "bundle sim returned failure");
            return Ok(None);
        }

        let mut gas_used_total = 0u64;
        for sim in &bundle_sims {
            gas_used_total = gas_used_total.saturating_add(sim.gas_used);
        }
        let bundle_gas_limit = gas_used_total.max(gas_limit_hint);
        let gas_cost_wei = U256::from(bundle_gas_limit) * U256::from(gas_fees.max_fee_per_gas);

        if !self.dry_run {
            let spend = if backrun.uses_flashloan {
                U256::ZERO
            } else {
                backrun.value.saturating_add(attack_value_eth)
            };
            self.portfolio
                .ensure_funding(self.chain_id, spend + gas_cost_wei)?;
        }

        let total_eth_in = backrun.value.saturating_add(attack_value_eth);
        let gross_profit_wei = backrun.expected_out.saturating_sub(total_eth_in);

        // --- PROFIT CHECK (MEV Share - U256 Safe) ---
        if gas_cost_wei > gross_profit_wei {
            self.log_skip("profit_or_gas_guard", "Gas > Gross Profit");
            return Ok(None);
        }

        let net_profit_wei = gross_profit_wei.saturating_sub(gas_cost_wei);
        let profit_floor = StrategyExecutor::dynamic_profit_floor(wallet_chain_balance);

        if net_profit_wei < profit_floor {
            self.log_skip(
                "profit_or_gas_guard",
                &format!("Net {} < Floor {}", net_profit_wei, profit_floor),
            );
            return Ok(None);
        }

        if !self.gas_ratio_ok(gas_cost_wei, gross_profit_wei, wallet_chain_balance) {
            self.log_skip("profit_or_gas_guard", "Bad Risk/Reward");
            return Ok(None);
        }

        let eth_quote = self.price_feed.get_price("ETHUSD").await?;
        let profit_eth_f64 = self.amount_to_display(gross_profit_wei, self.wrapped_native);
        let gas_cost_eth_f64 = self.amount_to_display(gas_cost_wei, self.wrapped_native);
        let net_profit_eth_f64 = self.amount_to_display(net_profit_wei, self.wrapped_native);

        tracing::info!(
            target: "strategy",
            gas_limit = bundle_gas_limit,
            max_fee_per_gas = gas_fees.max_fee_per_gas,
            gas_cost_eth = gas_cost_eth_f64,
            backrun_value_eth = self.amount_to_display(backrun.value, self.wrapped_native),
            expected_out_eth = self.amount_to_display(backrun.expected_out, self.wrapped_native),
            front_run_value_eth = self.amount_to_display(attack_value_eth, self.wrapped_native),
            net_profit_eth = net_profit_eth_f64,
            wallet_eth = self.amount_to_display(wallet_chain_balance, self.wrapped_native),
            price_source = %eth_quote.source,
            price = eth_quote.price,
            victim_min_out = ?observed_swap.min_out,
            victim_recipient = ?observed_swap.recipient,
            path_len = observed_swap.path.len(),
            path = ?observed_swap.path,
            router = ?observed_swap.router,
            used_mock_balance = self.dry_run,
            profit_floor_wei = %profit_floor,
            sandwich = front_run.is_some(),
            "MEV-Share strategy evaluation"
        );

        let tx_hash = format!("{:#x}", hint.tx_hash);

        if self.dry_run {
            tracing::info!(
                target: "strategy_dry_run",
                tx_hash = %tx_hash,
                net_profit_eth = net_profit_eth_f64,
                gross_profit_eth = profit_eth_f64,
                gas_cost_eth = gas_cost_eth_f64,
                front_run_value_eth = self.amount_to_display(attack_value_eth, self.wrapped_native),
                wallet_eth = self.amount_to_display(wallet_chain_balance, self.wrapped_native),
                path_len = observed_swap.path.len(),
                router = ?observed_swap.router,
                used_mock_balance = self.dry_run,
                sandwich = front_run.is_some(),
                "Dry-run only: simulated profitable MEV-Share bundle (not sent)"
            );
            return Ok(Some(tx_hash));
        }

        let _ = self.db.update_status(&tx_hash, None, Some(false)).await;

        if let Err(e) = self
            .bundle_sender
            .send_mev_share_bundle(&bundle_body)
            .await
        {
            self.emergency_exit_inventory("mev_share bundle send failed").await;
            return Err(e);
        }

        let from_addr = hint.from.unwrap_or(Address::ZERO);
        self.db
            .save_transaction(
                &tx_hash,
                self.chain_id,
                &format!("{:#x}", from_addr),
                Some(format!("{:#x}", hint.router)).as_deref(),
                hint.value.to_string().as_str(),
                Some("strategy_mev_share"),
            )
            .await?;

        self.db
            .save_transaction(
                &format!("{:#x}", backrun.hash),
                self.chain_id,
                &format!("{:#x}", self.signer.address()),
                Some(format!("{:#x}", backrun.to)).as_deref(),
                backrun.value.to_string().as_str(),
                Some("strategy_backrun"),
            )
            .await?;
        if let Some(f) = &front_run {
            self.db
                .save_transaction(
                    &format!("{:#x}", f.hash),
                    self.chain_id,
                    &format!("{:#x}", self.signer.address()),
                    Some(format!("{:#x}", f.to)).as_deref(),
                    f.value.to_string().as_str(),
                    Some("strategy_front_run"),
                )
                .await?;
        }

        self.db
            .save_profit_record(
                &tx_hash,
                self.chain_id,
                "strategy_mev_share",
                profit_eth_f64,
                gas_cost_eth_f64,
                net_profit_eth_f64,
            )
            .await?;

        self.portfolio
            .record_profit(self.chain_id, gross_profit_wei, gas_cost_wei);

        let _ = self
            .db
            .save_market_price(self.chain_id, "ETHUSD", eth_quote.price, &eth_quote.source)
            .await;

        let receipt_target = executor_hash.unwrap_or(backrun.hash);
        if !self.await_receipt(&receipt_target).await? {
            self.emergency_exit_inventory("mev_share receipt missing/failed").await;
        }

        Ok(Some(tx_hash))
    }

    fn dynamic_profit_floor(wallet_balance: U256) -> U256 {
        let abs_floor = *MIN_PROFIT_THRESHOLD_WEI;
        let scaled = wallet_balance
            .checked_div(U256::from(100_000u64))
            .unwrap_or(U256::ZERO);
        if scaled > abs_floor {
            scaled
        } else {
            abs_floor
        }
    }

    fn boost_fees(
        &self,
        fees: &mut GasFees,
        victim_max_fee: Option<u128>,
        victim_tip: Option<u128>,
    ) {
        let base_gwei = fees.base_fee_per_gas / 1_000_000_000u128;
        let mut boost_bps: u64 = if base_gwei > 80 {
            13000 // +30%
        } else if base_gwei > 40 {
            12000 // +20%
        } else {
            11000 // +10%
        };

        let pnl = self.portfolio.get_net_profit_i256(self.chain_id);
        // -0.1 ETH threshold approx in I256
        let neg_threshold = I256::from_raw(U256::from(100_000_000_000_000_000u128)).neg();

        if pnl < neg_threshold {
            boost_bps = (boost_bps as f64 * 0.8) as u64;
        } else if pnl.is_positive() {
            boost_bps = (boost_bps as f64 * 1.05) as u64;
        }
        boost_bps = boost_bps.max(10200).min(14500);

        let boost =
            |val: u128| -> u128 { (val.saturating_mul(boost_bps as u128) / 10_000u128).max(val) };
        fees.max_fee_per_gas = boost(fees.max_fee_per_gas);
        fees.max_priority_fee_per_gas = boost(fees.max_priority_fee_per_gas);

        let one_gwei: u128 = 1_000_000_000;
        let tip_floor = ((fees.base_fee_per_gas / 10).max(2 * one_gwei)).min(30 * one_gwei);
        if fees.max_priority_fee_per_gas < tip_floor {
            fees.max_priority_fee_per_gas = tip_floor;
        }
        let min_fee = fees
            .base_fee_per_gas
            .saturating_add(fees.max_priority_fee_per_gas);
        if fees.max_fee_per_gas < min_fee {
            fees.max_fee_per_gas = min_fee;
        }

        if let Some(v_fee) = victim_max_fee {
            let fee_target = v_fee.saturating_mul(VICTIM_FEE_BUMP_BPS as u128) / 10_000u128;
            fees.max_fee_per_gas = fees.max_fee_per_gas.max(fee_target);
        }
        if let Some(v_tip) = victim_tip {
            let tip_target = v_tip.saturating_mul(VICTIM_FEE_BUMP_BPS as u128) / 10_000u128;
            fees.max_priority_fee_per_gas = fees.max_priority_fee_per_gas.max(tip_target);
        }
    }

    fn gas_ratio_ok(
        &self,
        gas_cost_wei: U256,
        gross_profit_wei: U256,
        wallet_balance: U256,
    ) -> bool {
        if gross_profit_wei.is_zero() {
            return false;
        }
        let limit = self.dynamic_gas_ratio_limit(wallet_balance);
        gas_cost_wei.saturating_mul(U256::from(10_000u64))
            <= gross_profit_wei.saturating_mul(U256::from(limit))
    }

    fn dynamic_backrun_value(
        observed_in: U256,
        wallet_balance: U256,
        slippage_bps: u64,
        gas_limit_hint: u64,
        max_fee_per_gas: u128,
    ) -> Result<U256, AppError> {
        let mut value =
            observed_in.saturating_mul(U256::from(slippage_bps)) / U256::from(10_000u64);

        let min_backrun = U256::from(100_000_000_000_000u64);
        if value < min_backrun {
            value = min_backrun;
        }

        let (max_divisor, gas_buffer_divisor) = Self::backrun_divisors(wallet_balance);
        let mut max_value = wallet_balance
            .checked_div(U256::from(max_divisor))
            .unwrap_or(wallet_balance);
        let gas_buffer =
            U256::from(max_fee_per_gas).saturating_mul(U256::from(gas_limit_hint.max(210_000)));
        if gas_buffer > wallet_balance / U256::from(gas_buffer_divisor) {
            max_value = wallet_balance
                .checked_div(U256::from(gas_buffer_divisor))
                .unwrap_or(wallet_balance);
        }
        if value > max_value {
            value = max_value;
        }
        if value.is_zero() {
            return Err(AppError::Strategy(
                "Backrun value is zero after caps".into(),
            ));
        }
        Ok(value)
    }

    fn backrun_divisors(wallet_balance: U256) -> (u64, u64) {
        let thresholds = [
            (U256::from(100_000_000_000_000_000u128), (4u64, 6u64)), // <0.1 ETH
            (U256::from(500_000_000_000_000_000u128), (3u64, 5u64)), // <0.5 ETH
            (U256::from(2_000_000_000_000_000_000u128), (2u64, 4u64)), // <2 ETH
        ];
        for (limit, divisors) in thresholds {
            if wallet_balance < limit {
                return divisors;
            }
        }
        (2, 3)
    }

    fn dynamic_gas_ratio_limit(&self, wallet_balance: U256) -> u64 {
        let pnl = self.portfolio.get_net_profit_i256(self.chain_id);
        let base = if wallet_balance < U256::from(100_000_000_000_000_000u128) {
            5000
        } else if wallet_balance < U256::from(500_000_000_000_000_000u128) {
            6500
        } else if wallet_balance < U256::from(2_000_000_000_000_000_000u128) {
            8000
        } else {
            9000
        };

        // Convert U256 PnL thresholds to I256 for comparison
        let neg_0_05 = I256::from_raw(U256::from(50_000_000_000_000_000u128)).neg();
        let pos_0_2 = I256::from_raw(U256::from(200_000_000_000_000_000u128));

        if pnl < neg_0_05 {
            (base * 85 / 100).max(3500) // tighten 15%
        } else if pnl.is_negative() {
            (base * 92 / 100).max(4000) // tighten 8%
        } else if pnl > pos_0_2 {
            (base * 105 / 100).min(9500)
        } else {
            base
        }
    }

    async fn quote_v3_path(&self, path: &[u8], amount_in: U256) -> Result<U256, AppError> {
        let quoter_addr = Self::v3_quoter_for_chain(self.chain_id)
            .ok_or_else(|| AppError::Strategy("No V3 quoter configured for chain".into()))?;
        let quoter = UniV3Quoter::new(quoter_addr, self.http_provider.clone());
        let amount_in_cloned = amount_in;
        let path_vec = path.to_vec();
        let out: U256 = retry_async(
            move |_| {
                let q = quoter.clone();
                let p = path_vec.clone();
                async move { q.quoteExactInput(p.into(), amount_in_cloned).call().await }
            },
            3,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Strategy(format!("V3 path quote failed: {}", e)))?;
        Ok(out)
    }

    fn v3_quoter_for_chain(chain_id: u64) -> Option<Address> {
        match chain_id {
            CHAIN_ETHEREUM => Some(address!("b27308f9F90D607463bb33eA1BeBb41C27CE5AB6")),
            CHAIN_OPTIMISM | CHAIN_ARBITRUM | CHAIN_POLYGON => {
                Some(address!("61fFE014bA17989E743c5F6cB21bF9697530B21e"))
            }
            _ => None,
        }
    }

    fn decode_swap(tx: &Transaction) -> Option<ObservedSwap> {
        let router = match tx.kind() {
            TxKind::Call(addr) => addr,
            TxKind::Create => return None,
        };
        Self::decode_swap_input(router, tx.input(), tx.value())
    }

    fn decode_swap_input(router: Address, input: &[u8], eth_value: U256) -> Option<ObservedSwap> {
        if input.len() < 4 {
            return None;
        }

        let selector: [u8; 4] = input[..4].try_into().ok()?;
        match selector {
            swapExactETHForTokensCall::SELECTOR => {
                let decoded = swapExactETHForTokensCall::abi_decode(input).ok()?;
                Some(ObservedSwap {
                    router,
                    path: decoded.path,
                    v3_fees: Vec::new(),
                    v3_path: None,
                    amount_in: eth_value,
                    min_out: decoded.amountOutMin,
                    recipient: decoded.to,
                    router_kind: RouterKind::V2Like,
                })
            }
            swapExactTokensForETHCall::SELECTOR => {
                let decoded = swapExactTokensForETHCall::abi_decode(input).ok()?;
                Some(ObservedSwap {
                    router,
                    path: decoded.path,
                    v3_fees: Vec::new(),
                    v3_path: None,
                    amount_in: decoded.amountIn,
                    min_out: decoded.amountOutMin,
                    recipient: decoded.to,
                    router_kind: RouterKind::V2Like,
                })
            }
            swapExactTokensForTokensCall::SELECTOR => {
                let decoded = swapExactTokensForTokensCall::abi_decode(input).ok()?;
                Some(ObservedSwap {
                    router,
                    path: decoded.path,
                    v3_fees: Vec::new(),
                    v3_path: None,
                    amount_in: decoded.amountIn,
                    min_out: decoded.amountOutMin,
                    recipient: decoded.to,
                    router_kind: RouterKind::V2Like,
                })
            }
            UniV3Router::exactInputSingleCall::SELECTOR => {
                let decoded = UniV3Router::exactInputSingleCall::abi_decode(input).ok()?;
                let params = decoded.params;
                let path_bytes =
                    Self::encode_v3_path(&[params.tokenIn, params.tokenOut], &[params.fee.to()]);
                let fee_u32: u32 = params.fee.to::<u32>();
                if !Self::v3_fee_sane(fee_u32) {
                    return None;
                }
                if !Self::validate_v3_tokens(&[params.tokenIn, params.tokenOut]) {
                    return None;
                }
                Some(ObservedSwap {
                    router,
                    path: vec![params.tokenIn, params.tokenOut],
                    v3_fees: vec![fee_u32],
                    v3_path: path_bytes,
                    amount_in: params.amountIn,
                    min_out: params.amountOutMinimum,
                    recipient: params.recipient,
                    router_kind: RouterKind::V3Like,
                })
            }
            UniV3Router::exactInputCall::SELECTOR => {
                let decoded = UniV3Router::exactInputCall::abi_decode(input).ok()?;
                let params = decoded.params;
                let Some(path) = Self::parse_v3_path(&params.path) else {
                    return None;
                };
                Some(ObservedSwap {
                    router,
                    path: path.tokens.clone(),
                    v3_fees: path.fees.clone(),
                    v3_path: Some(params.path.to_vec()),
                    amount_in: params.amountIn,
                    min_out: params.amountOutMinimum,
                    recipient: params.recipient,
                    router_kind: RouterKind::V3Like,
                })
            }
            _ => None,
        }
    }

    fn target_token(path: &[Address], wrapped_native: Address) -> Option<Address> {
        path.iter().copied().find(|addr| addr != &wrapped_native)
    }

    fn direction(observed: &ObservedSwap, wrapped_native: Address) -> SwapDirection {
        let starts_with_native = observed.path.first().copied() == Some(wrapped_native);
        let ends_with_native = observed.path.last().copied() == Some(wrapped_native);
        if starts_with_native {
            SwapDirection::BuyWithEth
        } else if ends_with_native {
            SwapDirection::SellForEth
        } else {
            SwapDirection::Other
        }
    }

    fn parse_v3_path(path: &[u8]) -> Option<ParsedV3Path> {
        const ADDRESS_BYTES: usize = 20;
        const FEE_BYTES: usize = 3;
        const HOP_BYTES: usize = ADDRESS_BYTES + FEE_BYTES;

        // Need at least two tokens (one hop).
        if path.len() < ADDRESS_BYTES + HOP_BYTES {
            return None;
        }
        if (path.len() - ADDRESS_BYTES) % HOP_BYTES != 0 {
            return None;
        }

        let mut tokens = Vec::new();
        let mut fees = Vec::new();

        tokens.push(Address::from_slice(&path[..ADDRESS_BYTES]));

        for hop in path[ADDRESS_BYTES..].chunks_exact(HOP_BYTES) {
            let (fee_bytes, token_bytes) = hop.split_at(FEE_BYTES);
            let fee = U24::try_from_be_slice(fee_bytes)?.to::<u32>();
            if !Self::v3_fee_sane(fee) {
                return None;
            }
            tokens.push(Address::from_slice(token_bytes));
            fees.push(fee);
        }

        if !Self::validate_v3_tokens(&tokens) {
            return None;
        }

        Some(ParsedV3Path { tokens, fees })
    }

    fn encode_v3_path(tokens: &[Address], fees: &[u32]) -> Option<Vec<u8>> {
        if tokens.len() < 2 || fees.len() + 1 != tokens.len() {
            return None;
        }
        let mut out: Vec<u8> = Vec::with_capacity(tokens.len() * 23);
        out.extend_from_slice(tokens[0].as_slice());
        for (i, fee) in fees.iter().enumerate() {
            out.extend_from_slice(&fee.to_be_bytes()[1..]); // take last 3 bytes
            out.extend_from_slice(tokens[i + 1].as_slice());
        }
        Some(out)
    }

    fn reverse_v3_path(tokens: &[Address], fees: &[u32]) -> Option<Vec<u8>> {
        if tokens.len() < 2 || fees.len() + 1 != tokens.len() {
            return None;
        }
        let rev_tokens: Vec<Address> = tokens.iter().rev().copied().collect();
        let rev_fees: Vec<u32> = fees.iter().rev().copied().collect();
        // When reversing path, token count stays same, fees reversed.
        Self::encode_v3_path(&rev_tokens, &rev_fees)
    }

    fn v3_fee_sane(fee: u32) -> bool {
        matches!(fee, 500 | 3000 | 10_000)
    }

    fn build_access_list(router: Address, tokens: &[Address]) -> AccessList {
        let mut seen = HashSet::new();
        let mut items: Vec<AccessListItem> = Vec::new();
        let push = |addr: Address, seen: &mut HashSet<Address>, items: &mut Vec<AccessListItem>| {
            if seen.insert(addr) {
                items.push(AccessListItem {
                    address: addr,
                    storage_keys: Vec::new(),
                });
            }
        };
        push(router, &mut seen, &mut items);
        for t in tokens {
            push(*t, &mut seen, &mut items);
        }
        AccessList(items)
    }

    fn validate_v3_tokens(tokens: &[Address]) -> bool {
        let max_hops = 4; // up to 4 tokens (3 hops) to bound complexity
        if tokens.len() < 2 || tokens.len() > max_hops {
            return false;
        }
        true
    }

    fn build_v3_swap_payload(
        &self,
        router: Address,
        path: Vec<u8>,
        amount_in: U256,
        amount_out_min: U256,
        recipient: Address,
    ) -> Vec<u8> {
        let deadline = current_unix().saturating_add(60);
        UniV3Router::new(router, self.http_provider.clone())
            .exactInput(UniV3Router::ExactInputParams {
                path: path.into(),
                recipient,
                deadline: U256::from(deadline),
                amountIn: amount_in,
                amountOutMinimum: amount_out_min,
            })
            .calldata()
            .to_vec()
    }

    fn build_v2_swap_payload(
        &self,
        path: Vec<Address>,
        amount_in: U256,
        amount_out_min: U256,
        recipient: Address,
        use_flashloan: bool,
    ) -> Vec<u8> {
        let deadline = U256::from(current_unix().saturating_add(60));

        // Buy path: wrapped_native -> token (or multi-hop starting with wrapped)
        if path.first().copied() == Some(self.wrapped_native) {
            if use_flashloan {
                // We hold wrapped native as ERC20; use token-for-token swap.
                UniV2Router::swapExactTokensForTokensCall {
                    amountIn: amount_in,
                    amountOutMin: amount_out_min,
                    path,
                    to: recipient,
                    deadline,
                }
                .abi_encode()
            } else {
                // We pay native ETH; value is set on tx, calldata uses ETH entrypoint.
                UniV2Router::swapExactETHForTokensCall {
                    amountOutMin: amount_out_min,
                    path,
                    to: recipient,
                    deadline,
                }
                .abi_encode()
            }
        } else {
            // Sell path: token -> wrapped_native (potentially multi-hop)
            if use_flashloan {
                UniV2Router::swapExactTokensForTokensCall {
                    amountIn: amount_in,
                    amountOutMin: amount_out_min,
                    path,
                    to: recipient,
                    deadline,
                }
                .abi_encode()
            } else {
                UniV2Router::swapExactTokensForETHCall {
                    amountIn: amount_in,
                    amountOutMin: amount_out_min,
                    path,
                    to: recipient,
                    deadline,
                }
                .abi_encode()
            }
        }
    }

    async fn maybe_rebalance_inventory(&self) -> Result<(), AppError> {
        let mut guard = self.last_rebalance.lock().await;
        if guard.elapsed().as_secs() < 60 {
            return Ok(());
        }
        *guard = Instant::now();
        drop(guard);

        let routers: Vec<Address> = self.router_allowlist.iter().copied().collect();
        if routers.is_empty() {
            return Ok(());
        }

        let tokens: Vec<Address> = self.inventory_tokens.iter().map(|t| *t).collect();
        for token in tokens.into_iter().take(2) {
            for router in routers.iter().copied().take(3) {
                if self.rebalance_token(token, router).await.is_ok() {
                    break;
                }
            }
        }
        Ok(())
    }

    async fn rebalance_token(&self, token: Address, router: Address) -> Result<(), AppError> {
        if token == self.wrapped_native {
            return Ok(());
        }
        if self.toxic_tokens.contains(&token) {
            return Ok(());
        }
        // Check balance
        let erc20 = ERC20::new(token, self.http_provider.clone());
        let bal: U256 = retry_async(
            move |_| {
                let c = erc20.clone();
                async move { c.balanceOf(self.signer.address()).call().await }
            },
            2,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Strategy(format!("Inventory balance failed: {}", e)))?;
        if bal.is_zero() {
            return Ok(());
        }

        let mut gas_fees: GasFees = self.gas_oracle.estimate_eip1559_fees().await?;
        self.boost_fees(&mut gas_fees, None, None);
        let gas_cap_wei = U256::from(self.max_gas_price_gwei) * U256::from(1_000_000_000u64);
        if U256::from(gas_fees.max_fee_per_gas) > gas_cap_wei {
            return Ok(());
        }

        // Quote token -> wrapped_native on V2 (liquidity check)
        let router_contract = UniV2Router::new(router, self.http_provider.clone());
        let sell_path = vec![token, self.wrapped_native];
        let quote_path = sell_path.clone();
        let quote_contract = router_contract.clone();
        let sell_amount = bal;
        let quote: Vec<U256> = match retry_async(
            move |_| {
                let c = quote_contract.clone();
                let p = quote_path.clone();
                async move { c.getAmountsOut(sell_amount, p.clone()).call().await }
            },
            2,
            Duration::from_millis(100),
        )
        .await
        {
            Ok(v) => v,
            Err(_) => return Ok(()), // skip silently
        };
        let Some(expected_out) = quote.last().copied() else {
            return Ok(());
        };
        // Quick liquidity sanity: ensure intermediate amount scales roughly linearly
        if quote.len() >= 2 {
            let first_hop = quote[1];
            if first_hop.is_zero() || expected_out.is_zero() {
                return Ok(());
            }
        }
        // Skip tiny balances (<0.01 ETH)
        let min_eth = U256::from(10_000_000_000_000_000u128);
        if expected_out < min_eth {
            return Ok(());
        }
        // Avoid sweeping illiquid tokens where price impact is extreme (expected_out << sell_amount)
        if sell_amount > U256::ZERO {
            let ratio = expected_out.saturating_mul(U256::from(1_000_000u64)) / sell_amount;
            // Require at least 0.1% of notional back (ratio >= 1000 in ppm terms)
            if ratio < U256::from(1_000u64) {
                return Ok(());
            }
        }
        // Probe execution to avoid fee-on-transfer/honeypot tokens
        if !self
            .probe_v2_sell_for_toxicity(token, router, sell_amount, expected_out)
            .await?
        {
            return Ok(());
        }
        let min_out = expected_out.saturating_mul(U256::from(10_000u64 - self.slippage_bps))
            / U256::from(10_000u64);
        let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 300);

        // Allowance
        if self
            .needs_approval(token, router, sell_amount)
            .await
            .unwrap_or(true)
        {
            let nonce = self.nonce_manager.get_next_nonce().await?;
            let approval = self
                .build_approval_tx(
                    token,
                    router,
                    gas_fees.max_fee_per_gas,
                    gas_fees.max_priority_fee_per_gas,
                    nonce,
                )
                .await?;
            let _ = self
                .bundle_sender
                .send_bundle(&[approval.raw.clone()], self.chain_id)
                .await;
        }

        let nonce_sell = self.nonce_manager.get_next_nonce().await?;
        let gas_limit = 180_000u64;
        let calldata = router_contract
            .swapExactTokensForETH(
                sell_amount,
                min_out,
                sell_path,
                self.signer.address(),
                deadline,
            )
            .calldata()
            .to_vec();
        let mut request = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(router)),
            max_fee_per_gas: Some(gas_fees.max_fee_per_gas),
            max_priority_fee_per_gas: Some(gas_fees.max_priority_fee_per_gas),
            gas: Some(gas_limit),
            value: Some(U256::ZERO),
            input: TransactionInput::new(calldata.clone().into()),
            nonce: Some(nonce_sell),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };
        let access_list =
            self.apply_access_list(&mut request, Self::build_access_list(router, &[token])).await;
        let (raw, _, _) = self
            .sign_with_access_list(request, access_list)
            .await?;
        let _ = self.bundle_sender.send_bundle(&[raw], self.chain_id).await;

        Ok(())
    }

    async fn emergency_exit_inventory(&self, reason: &str) {
        let routers: Vec<Address> = self.router_allowlist.iter().copied().collect();
        if routers.is_empty() {
            tracing::warn!(target: "inventory", reason=%reason, "No routers available for emergency exit");
            return;
        }

        let tokens: Vec<Address> = self.inventory_tokens.iter().map(|t| *t).collect();
        for token in tokens {
            for router in routers.iter().copied() {
                match self.rebalance_token(token, router).await {
                    Ok(_) => {
                        tracing::warn!(
                            target: "inventory",
                            reason=%reason,
                            token=%format!("{:#x}", token),
                            router=%format!("{:#x}", router),
                            "Emergency exit attempted"
                        );
                        break;
                    }
                    Err(e) => {
                        tracing::warn!(
                            target: "inventory",
                            reason=%reason,
                            token=%format!("{:#x}", token),
                            router=%format!("{:#x}", router),
                            error=%e,
                            "Emergency exit failed, trying next router"
                        );
                        continue;
                    }
                }
            }
        }
    }

    fn mark_toxic_token(&self, token: Address, reason: &str) {
        if self.toxic_tokens.insert(token) {
            tracing::warn!(
                target: "strategy",
                token = %format!("{:#x}", token),
                %reason,
                "Token marked toxic; skipping sweeps"
            );
        }
    }

    async fn probe_v2_sell_for_toxicity(
        &self,
        token: Address,
        router: Address,
        sell_amount: U256,
        expected_out: U256,
    ) -> Result<bool, AppError> {
        if sell_amount.is_zero() || expected_out.is_zero() {
            return Ok(false);
        }
        if self.toxic_tokens.contains(&token) {
            return Ok(false);
        }
        // Build a simulated approval + sell to detect fee-on-transfer / honeypots.
        let approve_calldata = ERC20::new(token, self.http_provider.clone())
            .approve(router, U256::MAX)
            .calldata()
            .to_vec();
        let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 60);
        let sell_calldata = UniV2Router::new(router, self.http_provider.clone())
            .swapExactTokensForETH(
                sell_amount,
                U256::ZERO, // allow any out for probe
                vec![token, self.wrapped_native],
                self.signer.address(),
                deadline,
            )
            .calldata()
            .to_vec();

        let approve_req = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(token)),
            gas: Some(70_000),
            value: Some(U256::ZERO),
            input: TransactionInput::new(approve_calldata.into()),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };
        let sell_req = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(router)),
            gas: Some(PROBE_GAS_LIMIT),
            value: Some(U256::ZERO),
            input: TransactionInput::new(sell_calldata.into()),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };

        let sims = self
            .simulator
            .simulate_bundle_requests(&[approve_req, sell_req], None)
            .await?;
        if sims.len() < 2 {
            tracing::debug!(
                target: "strategy",
                token = %format!("{:#x}", token),
                "Probe simulation missing results; skipping toxicity mark"
            );
            return Ok(true);
        }
        let outcome = &sims[1];
        if !outcome.success {
            self.mark_toxic_token(token, "probe_revert");
            return Ok(false);
        }

        if outcome.return_data.is_empty() {
            return Ok(true);
        }

        match swapExactTokensForETHCall::abi_decode_returns(&outcome.return_data) {
            Ok(amounts) => {
                let Some(actual_out) = amounts.last() else {
                    return Ok(true);
                };
                let tolerance_bps = U256::from(10_000u64 - TAX_TOLERANCE_BPS);
                let ok = actual_out.saturating_mul(U256::from(10_000u64))
                    >= expected_out.saturating_mul(tolerance_bps);
                if !ok {
                    self.mark_toxic_token(token, "probe_output_too_low");
                }
                Ok(ok)
            }
            Err(_) => Ok(true),
        }
    }

    async fn probe_v3_sell_for_toxicity(
        &self,
        router: Address,
        path: Vec<u8>,
        amount_in: U256,
        expected_out: U256,
    ) -> Result<bool, AppError> {
        if amount_in.is_zero() || expected_out.is_zero() {
            return Ok(false);
        }
        let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 60);
        let calldata = UniV3Router::new(router, self.http_provider.clone())
            .exactInput(UniV3Router::ExactInputParams {
                path: path.clone().into(),
                recipient: self.signer.address(),
                deadline,
                amountIn: amount_in,
                amountOutMinimum: U256::ZERO,
            })
            .calldata()
            .to_vec();
        let req = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(router)),
            gas: Some(PROBE_GAS_LIMIT.saturating_mul(2)),
            value: Some(U256::ZERO),
            input: TransactionInput::new(Bytes::from(calldata)),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };
        let outcome = self.simulator.simulate_request(req, None).await?;
        if !outcome.success {
            tracing::debug!(target: "strategy", "V3 probe revert; marking toxic");
            return Ok(false);
        }
        if outcome.return_data.is_empty() {
            return Ok(true);
        }
        match UniV3Router::exactInputCall::abi_decode_returns(&outcome.return_data) {
            Ok(amount_out) => {
                let tolerance_bps = U256::from(10_000u64 - TAX_TOLERANCE_BPS);
                let ok = amount_out.saturating_mul(U256::from(10_000u64))
                    >= expected_out.saturating_mul(tolerance_bps);
                Ok(ok)
            }
            Err(_) => Ok(true),
        }
    }

    async fn needs_approval(
        &self,
        token: Address,
        spender: Address,
        required: U256,
    ) -> Result<bool, AppError> {
        let erc20 = ERC20::new(token, self.http_provider.clone());
        let allowance: U256 = retry_async(
            move |_| {
                let c = erc20.clone();
                async move { c.allowance(self.signer.address(), spender).call().await }
            },
            2,
            Duration::from_millis(100),
        )
        .await
        .map_err(|e| AppError::Strategy(format!("Allowance check failed: {}", e)))?;
        Ok(allowance < required)
    }

    async fn build_approval_tx(
        &self,
        token: Address,
        spender: Address,
        max_fee_per_gas: u128,
        max_priority_fee_per_gas: u128,
        nonce: u64,
    ) -> Result<ApproveTx, AppError> {
        let calldata = ERC20::new(token, self.http_provider.clone())
            .approve(spender, U256::MAX)
            .calldata()
            .to_vec();
        let gas_limit = 70_000u64;
        let fallback = Self::build_access_list(spender, &[token]);
        let (raw, request, _) = self
            .sign_swap_request(
                token,
                gas_limit,
                U256::ZERO,
                max_fee_per_gas,
                max_priority_fee_per_gas,
                nonce,
                calldata,
                fallback,
            )
            .await?;

        Ok(ApproveTx { raw, request })
    }

    async fn build_executor_wrapper(
        &self,
        approval: Option<&ApproveTx>,
        backrun: &BackrunTx,
        gas_fees: &GasFees,
        gas_limit_hint: u64,
        nonce: u64,
    ) -> Result<Option<(Vec<u8>, TransactionRequest, B256)>, AppError> {
        let exec_addr = match self.executor {
            Some(addr) => addr,
            None => return Ok(None),
        };

        // Guard: avoid wrapping V3 paths or flashloan legs in the executor since
        // it would not hold the required allowances/funds as msg.sender.
        if backrun.router_kind == RouterKind::V3Like || backrun.uses_flashloan {
            return Ok(None);
        }

        let mut targets = Vec::new();
        let mut payloads = Vec::new();
        let mut values = Vec::new();
        if let Some(app) = approval {
            if let Some(TxKind::Call(addr)) = app.request.to {
                targets.push(addr);
                let bytes = app.request.input.clone().into_input().unwrap_or_default();
                payloads.push(bytes);
                values.push(U256::ZERO);
            }
        }
        if let Some(TxKind::Call(addr)) = backrun.request.to {
            targets.push(addr);
            let bytes = backrun
                .request
                .input
                .clone()
                .into_input()
                .unwrap_or_default();
            payloads.push(bytes);
            values.push(backrun.value);
        }

        if targets.is_empty() {
            return Ok(None);
        }

        let mut gas_limit = backrun
            .request
            .gas
            .unwrap_or(gas_limit_hint)
            .saturating_add(approval.and_then(|a| a.request.gas).unwrap_or(0))
            .saturating_add(80_000);

        if gas_limit < 150_000 {
            gas_limit = 150_000;
        }

        let mut bribe = U256::ZERO;
        if self.executor_bribe_bps > 0 {
            let base = U256::from(gas_limit).saturating_mul(U256::from(gas_fees.max_fee_per_gas));
            bribe =
                base.saturating_mul(U256::from(self.executor_bribe_bps)) / U256::from(10_000u64);
        }
        let bribe_recipient = self.executor_bribe_recipient.unwrap_or(Address::ZERO);

        let total_value = values
            .iter()
            .copied()
            .fold(U256::ZERO, |acc, v| acc.saturating_add(v))
            .saturating_add(bribe);

        let exec_call = UnifiedHardenedExecutor::executeBundleCall {
            targets,
            payloads,
            values,
            bribeRecipient: bribe_recipient,
            bribeAmount: bribe,
        };
        let calldata = exec_call.abi_encode();

        let (raw, request, hash) = self
            .sign_swap_request(
                exec_addr,
                gas_limit,
                total_value,
                gas_fees.max_fee_per_gas,
                gas_fees.max_priority_fee_per_gas,
                nonce,
                calldata,
                AccessList::default(),
            )
            .await?;

        Ok(Some((raw, request, hash)))
    }

    fn should_use_flashloan(
        &self,
        required_value: U256,
        wallet_balance: U256,
        gas_fees: &GasFees,
    ) -> bool {
        if !self.flashloan_enabled || self.executor.is_none() || self.dry_run {
            return false;
        }
        // If balance can't cover notional + small buffer, flashloan.
        let safety_buffer = U256::from(2_000_000_000_000_000u128); // 0.002 ETH
        if wallet_balance < required_value.saturating_add(safety_buffer) {
            return true;
        }
        // Estimate extra gas overhead for flashloan path; if remaining balance after trade is below this, prefer flashloan.
        let overhead_gas = U256::from(180_000u64);
        let overhead_cost = overhead_gas.saturating_mul(U256::from(gas_fees.max_fee_per_gas));
        let remaining = wallet_balance.saturating_sub(required_value);
        remaining < overhead_cost
    }

    async fn build_flashloan_transaction(
        &self,
        executor: Address,
        asset: Address,
        amount: U256,
        router: Address,
        swap_payload: Vec<u8>,
        approve_token: Option<Address>,
        gas_limit_hint: u64,
        gas_fees: &GasFees,
        nonce: u64,
    ) -> Result<(Vec<u8>, TransactionRequest, B256), AppError> {
        let mut targets = Vec::new();
        let mut values = Vec::new();
        let mut payloads = Vec::new();

        if let Some(tok) = approve_token {
            let approve = ERC20::approveCall {
                spender: router,
                amount: U256::MAX,
            };
            targets.push(tok);
            values.push(U256::ZERO);
            payloads.push(Bytes::from(approve.abi_encode()));
        }

        targets.push(router);
        values.push(U256::ZERO);
        payloads.push(Bytes::from(swap_payload));

        let callback = FlashCallbackData {
            targets,
            values,
            payloads,
        };
        let params = callback.abi_encode();

        let exec_call = UnifiedHardenedExecutor::executeFlashLoanCall {
            assets: vec![asset],
            amounts: vec![amount],
            params: Bytes::from(params),
        };
        let calldata = exec_call.abi_encode();

        let mut gas_limit = gas_limit_hint.saturating_add(150_000);
        if gas_limit < 220_000 {
            gas_limit = 220_000;
        }

        let request = TransactionRequest {
            from: Some(self.signer.address()),
            to: Some(TxKind::Call(executor)),
            max_fee_per_gas: Some(gas_fees.max_fee_per_gas),
            max_priority_fee_per_gas: Some(gas_fees.max_priority_fee_per_gas),
            gas: Some(gas_limit),
            value: Some(U256::ZERO),
            input: TransactionInput::new(calldata.into()),
            nonce: Some(nonce),
            chain_id: Some(self.chain_id),
            ..Default::default()
        };

        self.sign_with_access_list(request, AccessList::default()).await
    }

    fn is_common_token_call(input: &[u8]) -> bool {
        if input.len() < 4 {
            return false;
        }
        let selector = &input[..4];
        const TRANSFER: [u8; 4] = [0xa9, 0x05, 0x9c, 0xbb];
        const TRANSFER_FROM: [u8; 4] = [0x23, 0xb8, 0x72, 0xdd];
        const APPROVE: [u8; 4] = [0x09, 0x5e, 0xa7, 0xb3];
        const PERMIT: [u8; 4] = [0xd5, 0x05, 0xac, 0xcf]; // EIP-2612
        selector == TRANSFER
            || selector == TRANSFER_FROM
            || selector == APPROVE
            || selector == PERMIT
    }

    async fn build_front_run_tx(
        &self,
        observed: &ObservedSwap,
        max_fee_per_gas: u128,
        max_priority_fee_per_gas: u128,
        wallet_balance: U256,
        gas_limit_hint: u64,
        nonce: u64,
    ) -> Result<Option<FrontRunTx>, AppError> {
        if wallet_balance.is_zero() {
            return Ok(None);
        }
        let target_token = Self::target_token(&observed.path, self.wrapped_native)
            .ok_or_else(|| AppError::Strategy("Unable to derive target token".into()))?;

        let value = StrategyExecutor::dynamic_backrun_value(
            observed.amount_in,
            wallet_balance,
            self.slippage_bps,
            gas_limit_hint,
            max_fee_per_gas,
        )?;

        let (expected_tokens, calldata, value, gas_limit, access_list) = match observed.router_kind
        {
            RouterKind::V2Like => {
                let router_contract = UniV2Router::new(observed.router, self.http_provider.clone());
                let path = vec![self.wrapped_native, target_token];
                let access_list = Self::build_access_list(observed.router, &path);
                let quote_path = path.clone();
                let quote_contract = router_contract.clone();
                let quote_value = value;
                let quote: Vec<U256> = retry_async(
                    move |_| {
                        let c = quote_contract.clone();
                        let p = quote_path.clone();
                        async move { c.getAmountsOut(quote_value, p.clone()).call().await }
                    },
                    3,
                    Duration::from_millis(100),
                )
                .await
                .map_err(|e| AppError::Strategy(format!("Front-run quote failed: {}", e)))?;
                let expected_tokens = *quote
                    .last()
                    .ok_or_else(|| AppError::Strategy("Front-run quote missing amounts".into()))?;
                let ratio_ppm = Self::price_ratio_ppm(expected_tokens, value);
                if ratio_ppm < U256::from(1_000u64) {
                    return Ok(None); // skip illiquid paths quietly
                }
                let min_out = expected_tokens
                    .saturating_mul(U256::from(10_000u64 - self.slippage_bps))
                    / U256::from(10_000u64);
                let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 300);
                let calldata = router_contract
                    .swapExactETHForTokens(min_out, path, self.signer.address(), deadline)
                    .calldata()
                    .to_vec();
                let mut gas_limit = gas_limit_hint
                    .saturating_mul(11)
                    .checked_div(10)
                    .unwrap_or(300_000);
                if gas_limit < 160_000 {
                    gas_limit = 160_000;
                }
                (expected_tokens, calldata, value, gas_limit, access_list)
            }
            RouterKind::V3Like => {
                if observed.path.len() < 2 {
                    return Err(AppError::Strategy("V3 path too short".into()));
                }
                let recipient = self.signer.address();
                let path_bytes = if let Some(p) = observed.v3_path.clone() {
                    p
                } else {
                    Self::encode_v3_path(&observed.path, &observed.v3_fees)
                        .ok_or_else(|| AppError::Strategy("Encode V3 path failed".into()))?
                };
                if observed.path.first().copied() != Some(self.wrapped_native) {
                    return Ok(None);
                }
                let expected_tokens = self.quote_v3_path(&path_bytes, value).await?;
                let ratio_ppm = Self::price_ratio_ppm(expected_tokens, value);
                if ratio_ppm < U256::from(1_000u64) {
                    return Ok(None);
                }
                let min_out = expected_tokens
                    .saturating_mul(U256::from(10_000u64 - self.slippage_bps))
                    / U256::from(10_000u64);
                let access_list = Self::build_access_list(observed.router, &observed.path);
                let calldata = self.build_v3_swap_payload(
                    observed.router,
                    path_bytes.clone(),
                    value,
                    min_out,
                    recipient,
                );
                let mut gas_limit = gas_limit_hint
                    .saturating_mul(12)
                    .checked_div(10)
                    .unwrap_or(320_000);
                if gas_limit < 200_000 {
                    gas_limit = 200_000;
                }
                (expected_tokens, calldata, value, gas_limit, access_list)
            }
        };

        let (raw, request, hash) = self
            .sign_swap_request(
                observed.router,
                gas_limit,
                value,
                max_fee_per_gas,
                max_priority_fee_per_gas,
                nonce,
                calldata,
                access_list,
            )
            .await?;

        Ok(Some(FrontRunTx {
            raw,
            hash,
            to: observed.router,
            value,
            request,
            expected_tokens,
        }))
    }

    async fn build_backrun_tx(
        &self,
        observed: &ObservedSwap,
        max_fee_per_gas: u128,
        max_priority_fee_per_gas: u128,
        wallet_balance: U256,
        gas_limit_hint: u64,
        token_in_override: Option<U256>,
        use_flashloan: bool,
        nonce: u64,
    ) -> Result<BackrunTx, AppError> {
        let target_token = Self::target_token(&observed.path, self.wrapped_native)
            .ok_or_else(|| AppError::Strategy("Unable to derive target token".into()))?;

        if wallet_balance.is_zero() {
            return Err(AppError::Strategy(
                "No balance available for backrun".into(),
            ));
        }

        let (value, expected_out, calldata, access_list) = if let Some(tokens_in) =
            token_in_override
        {
            match observed.router_kind {
                RouterKind::V2Like => {
                    let router_contract =
                        UniV2Router::new(observed.router, self.http_provider.clone());
                    let sell_path = vec![target_token, self.wrapped_native];
                    let quote_path = sell_path.clone();
                    let quote_contract = router_contract.clone();
                    let sell_amount = tokens_in;
                    let quote: Vec<U256> = retry_async(
                        move |_| {
                            let c = quote_contract.clone();
                            let p = quote_path.clone();
                            async move { c.getAmountsOut(sell_amount, p.clone()).call().await }
                        },
                        3,
                        Duration::from_millis(100),
                    )
                    .await
                    .map_err(|e| AppError::Strategy(format!("Sell quote failed: {}", e)))?;
                    let expected_out = *quote
                        .last()
                        .ok_or_else(|| AppError::Strategy("Sell quote missing amounts".into()))?;
                    // Liquidity sanity: require minimal return relative to notional (avoid >99.9% impact)
                    let ratio_ppm = Self::price_ratio_ppm(expected_out, sell_amount);
                    if ratio_ppm < U256::from(1_000u64) {
                        return Err(AppError::Strategy("Sell liquidity too low".into()));
                    }
                    if !self.dry_run {
                        // Probe toxicity before trusting expected_out
                        if !self
                            .probe_v2_sell_for_toxicity(
                                target_token,
                                observed.router,
                                sell_amount,
                                expected_out,
                            )
                            .await?
                        {
                            return Err(AppError::Strategy(
                                "toxic token detected on backrun".into(),
                            ));
                        }
                    }
                    let min_out = expected_out
                        .saturating_mul(U256::from(10_000u64 - self.slippage_bps))
                        / U256::from(10_000u64);
                    let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 300);
                    let calldata = router_contract
                        .swapExactTokensForETH(
                            sell_amount,
                            min_out,
                            sell_path.clone(),
                            self.signer.address(),
                            deadline,
                        )
                        .calldata()
                        .to_vec();
                    let access_list = Self::build_access_list(observed.router, &sell_path);
                    (U256::ZERO, expected_out, calldata, access_list)
                }
                RouterKind::V3Like => {
                    let rev_path = Self::reverse_v3_path(&observed.path, &observed.v3_fees)
                        .ok_or_else(|| AppError::Strategy("Reverse V3 path failed".into()))?;
                    let expected_out = self.quote_v3_path(&rev_path, tokens_in).await?;
                    let ratio_ppm = Self::price_ratio_ppm(expected_out, tokens_in);
                    if ratio_ppm < U256::from(1_000u64) {
                        return Err(AppError::Strategy("Sell liquidity too low".into()));
                    }
                    if !self.dry_run {
                        if !self
                            .probe_v3_sell_for_toxicity(
                                observed.router,
                                rev_path.clone(),
                                tokens_in,
                                expected_out,
                            )
                            .await?
                        {
                            self.mark_toxic_token(target_token, "v3_probe_shortfall");
                            return Err(AppError::Strategy(
                                "toxic token detected on backrun".into(),
                            ));
                        }
                    }
                    let min_out = expected_out
                        .saturating_mul(U256::from(10_000u64 - self.slippage_bps))
                        / U256::from(10_000u64);
                    let deadline = U256::from((chrono::Utc::now().timestamp() as u64) + 300);
                    let calldata = UniV3Router::new(observed.router, self.http_provider.clone())
                        .exactInput(UniV3Router::ExactInputParams {
                            path: rev_path.clone().into(),
                            recipient: self.signer.address(),
                            deadline,
                            amountIn: tokens_in,
                            amountOutMinimum: min_out,
                        })
                        .calldata()
                        .to_vec();
                    let access_list = Self::build_access_list(observed.router, &observed.path);
                    (U256::ZERO, expected_out, calldata, access_list)
                }
            }
        } else {
            match observed.router_kind {
                RouterKind::V2Like => {
                    let router_contract =
                        UniV2Router::new(observed.router, self.http_provider.clone());
                    let value = StrategyExecutor::dynamic_backrun_value(
                        observed.amount_in,
                        wallet_balance,
                        self.slippage_bps,
                        gas_limit_hint,
                        max_fee_per_gas,
                    )?;

                    // Default path: wrapped native -> target (or multi-hop ending in wrapped native)
                    let path = vec![self.wrapped_native, target_token];
                    let quote_path = path.clone();
                    let quote_contract = router_contract.clone();
                    let quote_value = value;
                    let quote: Vec<U256> = retry_async(
                        move |_| {
                            let c = quote_contract.clone();
                            let p = quote_path.clone();
                            async move { c.getAmountsOut(quote_value, p.clone()).call().await }
                        },
                        3,
                        Duration::from_millis(100),
                    )
                    .await
                    .map_err(|e| AppError::Strategy(format!("Quote failed: {}", e)))?;
                    let expected_out = *quote
                        .last()
                        .ok_or_else(|| AppError::Strategy("Quote missing amounts".into()))?;
                    let ratio_ppm = Self::price_ratio_ppm(expected_out, value);
                    if ratio_ppm < U256::from(1_000u64) {
                        return Err(AppError::Strategy("V2 liquidity too low".into()));
                    }

                    let min_out = expected_out
                        .saturating_mul(U256::from(10_000u64 - self.slippage_bps))
                        / U256::from(10_000u64);
                    let recipient = if use_flashloan {
                        self.executor.unwrap_or(self.signer.address())
                    } else {
                        self.signer.address()
                    };
                    let calldata = self.build_v2_swap_payload(
                        path.clone(),
                        value,
                        min_out,
                        recipient,
                        use_flashloan,
                    );
                    let access_list = Self::build_access_list(observed.router, &path);
                    let tx_value = if use_flashloan { U256::ZERO } else { value };
                    (tx_value, expected_out, calldata, access_list)
                }
                RouterKind::V3Like => {
                    return Err(AppError::Strategy(
                        "V3 double swap without owned tokens not supported".into(),
                    ));
                }
            }
        };

        let mut gas_limit = gas_limit_hint
            .saturating_mul(12)
            .checked_div(10)
            .unwrap_or(350_000);
        if gas_limit < 200_000 {
            gas_limit = 200_000;
        }

        let flashloan_ok = use_flashloan && self.executor.is_some() && token_in_override.is_none();
        if flashloan_ok {
            let exec_addr = self
                .executor
                .ok_or_else(|| AppError::Strategy("Missing flashloan executor".into()))?;
            let gas = GasFees {
                max_fee_per_gas,
                max_priority_fee_per_gas,
                base_fee_per_gas: 0,
            };
            let (raw, request, hash) = self.build_flashloan_transaction(
                exec_addr,
                self.wrapped_native,
                value,
                observed.router,
                calldata.clone(),
                Some(self.wrapped_native),
                gas_limit,
                &gas,
                nonce,
            )
            .await?;
            return Ok(BackrunTx {
                raw,
                hash,
                to: exec_addr,
                value: U256::ZERO,
                request,
                expected_out,
                uses_flashloan: true,
                router_kind: observed.router_kind,
            });
        }

        let (raw, request, hash) = self
            .sign_swap_request(
                observed.router,
                gas_limit,
                value,
                max_fee_per_gas,
                max_priority_fee_per_gas,
                nonce,
                calldata,
                access_list,
            )
            .await?;

        Ok(BackrunTx {
            raw,
            hash,
            to: observed.router,
            value,
            request,
            expected_out,
            uses_flashloan: false,
            router_kind: observed.router_kind,
        })
    }

    async fn await_receipt(&self, hash: &B256) -> Result<bool, AppError> {
        for _ in 0..3 {
            if let Ok(Some(rcpt)) = self.http_provider.get_transaction_receipt(*hash).await {
                let block_num = rcpt.block_number;
                let status = rcpt.status();
                let _ = self.db.update_status(
                    &format!("{:#x}", hash),
                    block_num.map(|b| b as i64),
                    Some(status),
                );
                return Ok(status);
            }
            tokio::time::sleep(std::time::Duration::from_millis(200)).await;
        }
        Ok(false)
    }
}

#[allow(dead_code)]
fn wei_to_eth_f64(value: U256) -> f64 {
    units_to_float(value, 18)
}

#[allow(dead_code)]
fn units_to_float(value: U256, decimals: u8) -> f64 {
    let scale = 10f64.powi(decimals as i32);
    let num = value.to_string().parse::<f64>().unwrap_or(0.0);
    num / scale
}

fn current_unix() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
}

#[cfg(test)]
mod tests {

    #[test]
    fn decodes_eth_swap() {
        let router = WETH_MAINNET;
        let call = swapExactETHForTokensCall {
            amountOutMin: U256::from(5u64),
            path: vec![WETH_MAINNET, Address::from([2u8; 20])],
            to: Address::from([3u8; 20]),
            deadline: U256::from(100u64),
        };
        let data = call.abi_encode();
        let decoded = StrategyExecutor::decode_swap_input(
            router,
            &data,
            U256::from(1_000_000_000_000_000_000u128),
        )
        .expect("decode");
        assert_eq!(decoded.path.len(), 2);
        assert_eq!(decoded.min_out, U256::from(5u64));
    }

    #[test]
    fn wei_to_eth_conversion() {
        let two_eth = U256::from(2_000_000_000_000_000_000u128);
        let eth = wei_to_eth_f64(two_eth);
        assert!((eth - 2.0).abs() < 1e-9);
    }

    #[test]
    fn decodes_uniswap_v3_exact_input_single() {
        let params = UniV3Router::ExactInputSingleParams {
            tokenIn: WETH_MAINNET,
            tokenOut: Address::from([2u8; 20]),
            fee: U24::from(500u32),
            recipient: Address::from([3u8; 20]),
            deadline: U256::from(100u64),
            amountIn: U256::from(1_000_000_000_000_000_000u128),
            amountOutMinimum: U256::from(5u64),
            sqrtPriceLimitX96: U160::ZERO,
        };
        let call = UniV3Router::exactInputSingleCall { params };
        let data = call.abi_encode();
        let decoded = StrategyExecutor::decode_swap_input(WETH_MAINNET, &data, U256::from(0u64))
            .expect("decode v3 single");
        assert_eq!(decoded.router_kind, RouterKind::V3Like);
        assert_eq!(decoded.path.len(), 2);
    }

    #[test]
    fn parses_uniswap_v3_path() {
        let mut path: Vec<u8> = Vec::new();
        path.extend_from_slice(WETH_MAINNET.as_slice());
        path.extend_from_slice(&[0u8, 1u8, 244u8]); // fee 500
        let out = Address::from([9u8; 20]);
        path.extend_from_slice(out.as_slice());
        let parsed = StrategyExecutor::parse_v3_path(&path).expect("parse path");
        assert_eq!(parsed.tokens.len(), 2);
        assert_eq!(parsed.tokens[1], out);
        assert_eq!(parsed.fees, vec![500]);
    }

    #[test]
    fn rejects_invalid_v3_path_length() {
        // Missing last token bytes.
        let mut path: Vec<u8> = Vec::new();
        path.extend_from_slice(WETH_MAINNET.as_slice());
        path.extend_from_slice(&[0u8, 1u8, 244u8]); // fee 500
        path.extend_from_slice(&[1u8; 10]); // truncated address
        assert!(StrategyExecutor::parse_v3_path(&path).is_none());
    }

    #[test]
    fn rejects_invalid_v3_fee() {
        let mut path: Vec<u8> = Vec::new();
        path.extend_from_slice(WETH_MAINNET.as_slice());
        path.extend_from_slice(&[0u8, 0u8, 1u8]); // fee 1 (not standard)
        path.extend_from_slice([2u8; 20].as_slice());
        assert!(StrategyExecutor::parse_v3_path(&path).is_none());
    }

    #[test]
    fn detects_token_calls() {
        let transfer_selector = [0xa9, 0x05, 0x9c, 0xbb, 0u8];
        assert!(StrategyExecutor::is_common_token_call(&transfer_selector));
        let random = [0x12, 0x34, 0x56, 0x78];
        assert!(!StrategyExecutor::is_common_token_call(&random));
    }

    #[test]
    fn classifies_swap_direction() {
        let buy = ObservedSwap {
            router: Address::ZERO,
            path: vec![WETH_MAINNET, Address::from([2u8; 20])],
            v3_fees: Vec::new(),
            v3_path: None,
            amount_in: U256::from(1u64),
            min_out: U256::ZERO,
            recipient: Address::ZERO,
            router_kind: RouterKind::V2Like,
        };
        assert_eq!(
            StrategyExecutor::direction(&buy, WETH_MAINNET),
            SwapDirection::BuyWithEth
        );
        let sell = ObservedSwap {
            path: vec![Address::from([2u8; 20]), WETH_MAINNET],
            ..buy
        };
        assert_eq!(
            StrategyExecutor::direction(&sell, WETH_MAINNET),
            SwapDirection::SellForEth
        );
    }
}
//==================================================================================================
// END:   services/strategy/strategy.rs
//==================================================================================================
